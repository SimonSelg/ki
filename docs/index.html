<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ki API documentation</title>
<meta name="description" content="Python package `ki` is a command-line interface for the version control and
editing of `.anki2` collections as git repositories of markdown files.
…" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:20%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
<link rel="canonical" href="ki/">
<link rel="icon" href="u1F367-shavedice.svg">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>ki</code></h1>
</header>
<section id="section-intro">
<p>Python package <code><a title="ki" href="#ki">ki</a></code> is a command-line interface for the version control and
editing of <code>.anki2</code> collections as git repositories of markdown files.
Rather than providing an interactive UI like the Anki desktop client, <code><a title="ki" href="#ki">ki</a></code> aims
to allow natural editing <em>in the filesystem</em>.</p>
<p>In general, the purpose of <code><a title="ki" href="#ki">ki</a></code> is to allow users to work on large, complex
Anki decks in exactly the same way they work on large, complex software
projects.</p>
<p><code><a title="ki" href="#ki">ki</a></code> provides command-line functions to:</p>
<ol>
<li><strong>clone</strong> a <code>.anki2</code> collection into a directory as a git repository.</li>
<li><strong>pull</strong> changes from the Anki desktop client (and AnkiWeb) into an existing
repository.</li>
<li><strong>push</strong> changes (safely!) back to Anki.</li>
</ol>
<h3 id="source-code">Source code</h3>
<p>This is documentation for the <code><a title="ki" href="#ki">ki</a></code>
<a href="https://github.com/langfield/ki">repository</a>. If you have <code>git</code>, you can clone
a local copy of the source code by running the following command in a terminal:</p>
<pre><code class="language-bash">git clone git@github.com:langfield/ki.git
</code></pre>
<h1 id="installation">Installation</h1>
<p><code><a title="ki" href="#ki">ki</a></code> is tested on Python 3.9 and Anki 2.1.49.</p>
<ol>
<li>Install the <code><a title="ki" href="#ki">ki</a></code> package from PyPI:</li>
</ol>
<pre><code class="language-bash">pip install anki-ki
</code></pre>
<h1 id="usage-reference">Usage reference</h1>
<h2 id="clone">Clone</h2>
<p>The <code><a title="ki" href="#ki">ki</a> clone</code> command takes one required argument (the path to a <code>.anki2</code>
file) and one optional argument (a path to a target directory). The usage is
meant to mirror that of <code>git clone</code>.</p>
<p>An example of the <code>clone</code> subcommand usage and its output is given below.</p>
<pre><code class="language-bash">$ ki clone ~/.local/share/Anki2/lyra/collection.anki2 decks
</code></pre>
<pre><code class="language-bash">Found .anki2 file at '/home/lyra/.local/share/Anki2/lyra/collection.anki2'
Computed md5sum: ad7ea6d486a327042cf0b09b54626b66
Wrote md5sum to '/home/lyra/decks/.ki/hashes'
Cloning into '/home/lyra/decks/'...
100%|█████████████████████████| 28886/28886 [00:10&lt;00:00, 2883.78it/s]
</code></pre>
<h2 id="pull">Pull</h2>
<p>Once an Anki collection has been cloned, we can <code>pull</code> changes made by the Anki
desktop client into our repository.</p>
<p>An example of the <code>pull</code> subcommand usage and its output is given below.</p>
<pre><code class="language-bash">$ ki pull
</code></pre>
<pre><code class="language-bash">Pulling from '/home/lyra/.local/share/Anki2/lyra/collection.anki2'
Computed md5sum: 199216c39eeabe23a1da016a99ffd3e2
Updating 5a9ef09..9c30b73
Fast-forward
 note1645010162168.md |  4 ++--
 note1645222430007.md | 11 +++++++++++
 2 files changed, 13 insertions(+), 2 deletions(-)
 create mode 100644 note1645222430007.md

From /tmp/tmpt5a3yd9a/ki/local/199216c39eeabe23a1da016a99ffd3e2/
 * branch            main       -&gt; FETCH_HEAD
 * [new branch]      main       -&gt; anki/main

Wrote md5sum to '/home/lyra/decks/.ki/hashes'
</code></pre>
<p><code><a title="ki" href="#ki">ki</a></code> first deletes any residual ephemeral repositories in <code>/tmp/ki/remote/</code>.
These would only remain here if a previous pull command failed.</p>
<p>It then verifies that the path to the <code>.anki2</code> file specified in the <code>.ki/</code>
directory (analogous to the <code>.git/</code> directory) still exists.</p>
<p>It computes and records the hash of the collection file. In this way, <code><a title="ki" href="#ki">ki</a></code>
keeps track of whether the collection database has changed since the last
<code>clone</code>/<code>pull</code>.</p>
<p>Finally, the collection is then cloned into an ephemeral repository in a temp
directory, which is then <code>git pull</code>-ed into the current repository.</p>
<p>At this point, if the git operation fails, the user can take over and manage
the merge themselves.</p>
<h2 id="push">Push</h2>
<p>When we want to push our changes back to the Anki desktop client, we can use
<code><a title="ki" href="#ki">ki</a> push</code> to do that.</p>
<p>An example of the <code>push</code> subcommand usage and its output is given below.</p>
<pre><code class="language-bash">$ ki push
</code></pre>
<pre><code class="language-bash">Pushing to '/home/lyra/.local/share/Anki2/lyra/collection.anki2'
Computed md5sum: 199216c39eeabe23a1da016a99ffd3e2
Verified md5sum matches latest hash in '/home/lyra/decks/.ki/hashes'
Generating local .anki2 file from latest commit: 2aa009729b6dd337dd1ce795df611f5a49
Writing changes to '/tmp/tmpyiids2qm/original.anki2'...
100%|█████████████████████████████████| 2/2 [00:00&lt;00:00, 1081.56it/s]
Database was modified.
Writing backup of .anki2 file to '/home/lyra/decks/.ki/backups'
Overwrote '/home/lyra/.local/share/Anki2/lyra/collection.anki2'
</code></pre>
<p>We store 5 backups of the collection prior to a push.</p>
<h1 id="getting-started">Getting started</h1>
<p>This section will walk through the following example workflow:</p>
<ol>
<li><a href="#cloning-a-collection"><strong>Cloning</strong></a> an existing collection into a <code><a title="ki" href="#ki">ki</a></code> repository.</li>
<li><a href="#editing-notes"><strong>Editing</strong></a> the note files in the repository.</li>
<li><a href="#pushing-committed-changes"><strong>Pushing</strong></a> those edits back to Anki.</li>
<li><a href="#pulling-changes-from-anki"><strong>Pulling</strong></a> changes made in Anki into the repository.</li>
</ol>
<p>Before cloning, we'll need to find our <code>.anki2</code> collection file.
This is where Anki stores the data for all our notes.</p>
<blockquote>
<p><strong>Note.</strong> If you're new to Anki, or are unfamiliar with the terms <em>collection</em>,
<em>profile</em>, <em>note</em>, or <em>card</em>, you may wish to take a look at the Anki
<a href="https://docs.ankiweb.net/intro.html">documentation</a>.</p>
</blockquote>
<p>If you already know the path to the <code>.anki2</code> collection file you want to clone,
skip to the section on <a href="#running-the-ki-clone-command">running the clone command</a>.</p>
<h3 id="finding-the-anki2-collection-file">Finding the <code>.anki2</code> collection file</h3>
<p>To find our collection file, we must first find our Anki data directory. The
location of this varies by operating system.</p>
<p>In most cases, you should be able to find your data directory at the path given
below for your respective OS:</p>
<h4 id="macos">MacOS</h4>
<pre><code class="language-bash">~/Library/Application Support/Anki2
</code></pre>
<h4 id="windows">Windows</h4>
<pre><code class="language-bash">%APPDATA%\Anki2
</code></pre>
<h4 id="gnulinux">GNU/Linux</h4>
<pre><code class="language-bash">~/.local/share/Anki2
</code></pre>
<blockquote>
<p><strong>Note.</strong> You can read more about the default Anki data directory locations
<a href="https://docs.ankiweb.net/files.html#file-locations">here</a>.</p>
</blockquote>
<hr>
<p>If you are running Anki 2.1 (which you should be, because <code><a title="ki" href="#ki">ki</a></code> is not tested
with lower versions), opening this directory will reveal several files and
subdirectories. The following example output is from a machine running Debian
GNU/Linux:</p>
<pre><code>user@host:~/.local/share/Anki2$ ls
 addons21   crash.log   prefs21.db   README.txt  'User 1'
</code></pre>
<p>In particular, there is a subdirectory for each <strong>profile</strong>. In the above
example, there is only one profile, <code>User 1</code>. But, in general, there may be
many profiles associated with a given Anki installation.</p>
<h4 id="multiple-profiles">Multiple profiles</h4>
<p>Below we can see a visual representation of the directory structure of an
Anki data directory with two profiles, <code>User 1</code>, and <code>User 2</code>:</p>
<pre><code class="language-bash">Anki2/
├── addons21
│   ├── 1046608507
│   ├── 109531687
│   ├── 1097423555
│   └── 1972239816
├── crash.log
├── prefs21.db
├── README.txt
├── User 1
│   ├── backups
│   ├── collection2.log
│   ├── collection.anki2
│   ├── collection.log
│   ├── collection.media
│   ├── collection.media.db2
│   └── deleted.txt
└── User 2
    ├── collection.anki2
    ├── collection.anki2-wal
    └── collection.media
</code></pre>
<p>Note that there is a <code>collection.anki2</code> file in each profile subdirectory.</p>
<p>If you're not sure of the name of your user profile, it can be seen in the
title bar of the Anki desktop client:</p>
<p align="center">
<img width="460" src="anki.png">
</p>
<p>Most Anki installations will only have one profile, and if you haven't changed
the default profile name, it will probably be called <code>User 1</code>. Let's enter the
profile directory for <code>User 1</code> and list its contents:</p>
<pre><code>user@host:~/.local/share/Anki2$ cd User\ 1/
user@host:~/.local/share/Anki2/User 1$ ls
backups  collection2.log  collection.anki2  collection.log  collection.media  collection.media.db2  deleted.txt
</code></pre>
<p>So if we want to clone <code>User 1</code>'s collection, the path that we want is:</p>
<pre><code>~/.local/share/Anki2/User\ 1/collection.anki2
</code></pre>
<p>We'll pass this as a command-line argument to the <code><a title="ki" href="#ki">ki</a></code> executable in the next
section.</p>
<h3 id="running-the-clone-command">Running the clone command</h3>
<p>Now we're ready to actually clone the collection into a repository. The <code><a title="ki" href="#ki">ki</a> clone</code>
command works similarly to <code>git clone</code>, in that it will create a new directory
for the repository <em>within</em> the current working directory. So if we want to
clone our collection into a new subdirectory in <code>~/</code> (the home directory on
macOS and GNU/Linux), we would first make sure we're in the home directory.
Second, we need to check that <strong>Anki is closed</strong> before cloning. Nothing bad
will happen if we clone while Anki is open, but the command will fail because
the database is locked. Once we've done that, we can run the command:</p>
<pre><code class="language-bash">ki clone ~/.local/share/Anki2/User 1/collection.anki2
</code></pre>
<p>And we should see output that looks similar to this:</p>
<pre><code class="language-bash">lyra@oxford$ ki clone ~/.local/share/Anki2/User 1/collection.anki2
Found .anki2 file at '/home/lyra/.local/share/Anki2/User 1/collection.anki2'
Computed md5sum: ad7ea6d486a327042cf0b09b54626b66
Wrote md5sum to '/home/lyra/collection/.ki/hashes'
Cloning into '/home/lyra/collection/'...
100%|█████████████████████████| 28886/28886 [00:10&lt;00:00, 2883.78it/s]
</code></pre>
<p>If we list the contents of the home directory, we can see that <code><a title="ki" href="#ki">ki</a></code> did
indeed create a new directory called <code>collection</code>:</p>
<pre><code class="language-bash">lyra@oxford:~$ ls
collection  pkgs
</code></pre>
<h2 id="editing-notes">Editing notes</h2>
<p>Now that we've successfully cloned our Anki collection into a <code><a title="ki" href="#ki">ki</a></code> repository,
we can start editing notes! Our home directory looks like this:</p>
<pre><code class="language-bash">lyra@oxford:~$ ls
collection  pkgs
</code></pre>
<p>And we see the repo we cloned, which is called <code>collection</code>.</p>
<p>Let's change directories to the newly cloned <code><a title="ki" href="#ki">ki</a></code> repo and take a look at
what's inside:</p>
<pre><code class="language-bash">lyra@oxford:~$ cd collection/
lyra@oxford:~/collection$ ls --classify
algebras/ manifolds/ rings/
</code></pre>
<p>We see that we have three directories, which represent three Anki decks. This
is just an example; you'll see directories corresponding to the top-level decks
in your Anki collection.</p>
<blockquote>
<p><strong>Note.</strong> The <code>ls --classify</code> command adds a trailing <code>/</code> to the end of
directories to distinguish them from ordinary files.</p>
</blockquote>
<p>Lets enter the <code>manifolds</code> directory and see what's inside.</p>
<pre><code class="language-bash">lyra@oxford:~/collection$ cd manifolds/
lyra@oxford:~/collection/manifolds$ ls
MANIFOLDS.md
</code></pre>
<p>So we see a single markdown file called <code>MANIFOLDS.md</code>, which contains the
notes for the manifolds deck. If we had subdecks of the manifolds deck, we
would see more subdirectories here, and each one would have a markdown file in
it as well. Lets open this file and see what's inside.</p>
<p>We'll use vim to open the markdown file in this example, but any text editor
will work.</p>
<pre><code class="language-bash">lyra@oxford:~/collection/manifolds$ vi MANIFOLDS.md
</code></pre>
<pre><code class="language-markdown"># Note
nid: 1622849751948
model: Basic
deck: manifolds
tags:
markdown: false

## Front
Diffeomorphism

## Back
A smooth surjective map between manifolds which has a smooth inverse.

# Note
nid: 1566621764508
model: Basic
deck: manifolds
tags:
markdown: false

## Front
distribution (on a smooth manifold)

## Back
A distribution on \(M\) of rank \(k\) is a rank-\(k\) subbundle of \(TM\)
</code></pre>
<p>So we see the structure of two notes inside this file. For each note, there is
a section for note metadata, and a section for each field.</p>
<p>There is a typo in the first note. It says <code>smooth surjective map</code>, but it
should say <code>smooth bijective map</code>. Lets fix it, save our changes, and go back
to the terminal. When we go back up to the root of the repository and run <code>git
status</code>, we can see which files we've changed.</p>
<blockquote>
<p><strong>INTERNAL.</strong> Add the output of git status here.</p>
</blockquote>
<p>And running <code>git diff</code> shows us the content of the unstaged changes:</p>
<blockquote>
<p><strong>INTERNAL.</strong> Add the output of git diff here.</p>
</blockquote>
<p>Then we can commit our changes as usual.</p>
<pre><code class="language-bash">lyra@oxford:~/collection$ git add manifolds/MANIFOLDS.md
lyra@oxford:~/collection$ git commit -m &quot;Fix typo in diffeomorphism definition: 'surjective' -&gt; 'bijective'&quot;
</code></pre>
<p>At this point we would usually <code>git push</code>, but if we try that in a <code><a title="ki" href="#ki">ki</a></code>
repository, we'll see this:</p>
<pre><code class="language-bash">lyra@oxford:~/collection$ git push
fatal: No configured push destination.
Either specify the URL from the command-line or configure a remote repository using

    git remote add &lt;name&gt; &lt;url&gt;

and then push using the remote name

    git push &lt;name&gt;

</code></pre>
<p>Since we're not pushing to an ordinary <code>git</code> remote, but to the Anki SQLite3
database, we must use <code><a title="ki" href="#ki">ki</a> push</code> instead, which is covered briefly in the next
section.</p>
<h2 id="pushing-committed-changes-back-to-anki">Pushing committed changes back to Anki</h2>
<p>This part is super easy! Similar to when we cloned, we must remember to <strong>close
Anki</strong> before pushing, or the command will fail (gracefully). All right, now we
just run the command:</p>
<pre><code class="language-bash">lyra@oxford:~/collection$ ki push
Pushing to '/home/lyra/.local/share/Anki2/lyra/collection.anki2'
Computed md5sum: 199216c39eeabe23a1da016a99ffd3e2
Verified md5sum matches latest hash in '/home/lyra/decks/.ki/hashes'
Generating local .anki2 file from latest commit: 2aa009729b6dd337dd1ce795df611f5a49
Writing changes to '/tmp/tmpyiids2qm/original.anki2'...
100%|█████████████████████████████████| 2/2 [00:00&lt;00:00, 1081.56it/s]
Database was modified.
Writing backup of .anki2 file to '/home/lyra/decks/.ki/backups'
Overwrote '/home/lyra/.local/share/Anki2/lyra/collection.anki2'
</code></pre>
<p>As the output suggests, <code><a title="ki" href="#ki">ki</a></code> saves a backup of our collection each time we
<code>push</code>, just in case we wish to hard-revert a change you've made.</p>
<p>Now we can open Anki and view the changes we've made in the note browser!</p>
<h2 id="pulling-changes-from-anki-into-the-repository">Pulling changes from Anki into the repository</h2>
<p>So now we know how to make changes from the filesystem and push them back to
Anki, but suppose that after we cloned our repository, we made some edits
<em>within</em> Anki, and we'd like those to show up in our repository? For this,
we'll need to <strong>close Anki</strong>, and then run the following command:</p>
<pre><code class="language-bash">lyra@oxford:~/collection$ ki pull
Pulling from '/home/lyra/.local/share/Anki2/lyra/collection.anki2'
Computed md5sum: 199216c39eeabe23a1da016a99ffd3e2
Updating 5a9ef09..9c30b73
Fast-forward
 note1645010162168.md |  4 ++--
 note1645222430007.md | 11 +++++++++++
 2 files changed, 13 insertions(+), 2 deletions(-)
 create mode 100644 note1645222430007.md

From /tmp/tmpt5a3yd9a/ki/local/199216c39eeabe23a1da016a99ffd3e2/
 * branch            main       -&gt; FETCH_HEAD
 * [new branch]      main       -&gt; anki/main

Wrote md5sum to '/home/lyra/decks/.ki/hashes'
</code></pre>
<p>And we're done! Our repository is up to date, as <code><a title="ki" href="#ki">ki</a></code> will tell us if we try to pull again:</p>
<pre><code class="language-bash">lyra@oxford:~/collection$ ki pull
ki pull: up to date.
</code></pre>
<h3 id="merge-conflicts">Merge conflicts</h3>
<p>Occasionally, when we edit the same lines in the same note fields in both Anki
and our local repository, we may encounter a merge conflict:</p>
<pre><code class="language-bash">lyra@oxford:~/collection$ ki pull
Pulling from '/home/lyra/.local/share/Anki2/User 1/collection.anki2'
Computed md5sum: debeb6689f0b83d520ff913067c598e9
Auto-merging note1645788806304.md
CONFLICT (add/add): Merge conflict in note1645788806304.md
Automatic merge failed; fix conflicts and then commit the result.

From /tmp/tmpgkq4ilfy/ki/local/debeb6689f0b83d520ff913067c598e9/
 * branch            main       -&gt; FETCH_HEAD
 * [new branch]      main       -&gt; anki/main

Wrote md5sum to '/home/mal/collection/.ki/hashes'
</code></pre>
<p>This is expected behavior, and since the process of resolving merge conflicts
is the same for <code><a title="ki" href="#ki">ki</a></code> repositories as <code>git</code> repositories (since <code><a title="ki" href="#ki">ki</a></code>
repositories <em>are</em> git repositories), we refer to
<a href="https://stackoverflow.com/questions/161813/how-to-resolve-merge-conflicts-in-a-git-repository">StackOverflow</a>
for how to proceed.</p>
<h1 id="collaborative-decks">Collaborative decks</h1>
<p>This section assumes knowledge of the basic <code><a title="ki" href="#ki">ki</a></code> operations and familiarity
with <code>git</code>. If you haven't yet cloned your Anki collection into a <code><a title="ki" href="#ki">ki</a></code>
repository, read the <a href="#getting-started">getting started</a> section.</p>
<ol>
<li><a href="#cloning-a-collaborative-deck-from-github"><strong>Cloning</strong></a> a collaborative deck from <a href="https://github.com/">GitHub</a>.</li>
<li><a href="#editing-a-collaborative-deck"><strong>Editing</strong></a> the collaborative deck.</li>
<li>[<strong>Pulling</strong>][pulling other users' changes from github] other users' changes to the deck from <a href="https://github.com/">GitHub</a>.</li>
<li>[<strong>Pushing</strong>][pushing edits back to github] edits back to <a href="https://github.com/">GitHub</a>.</li>
</ol>
<h2 id="cloning-a-collaborative-deck-from-github">Cloning a collaborative deck from GitHub</h2>
<p>Now that we've created our first <code><a title="ki" href="#ki">ki</a></code> repository, we might want to try our hand
at collaborating on a deck with other Anki users. We won't actually need to
make use of the <code><a title="ki" href="#ki">ki</a></code> program to do this, because <strong><code><a title="ki" href="#ki">ki</a></code> repositories are also
git repositories</strong>, and so we can clone collaborative decks from GitHub as
<code>git-submodules</code> of our collection repo.</p>
<blockquote>
<p><strong>Note.</strong> If you're completely unfamiliar with <code>git</code>, consider reading this
short
<a href="https://blog.teamtreehouse.com/git-for-designers-part-1">introduction</a>.</p>
</blockquote>
<p>Suppose we've cloned an Anki collection into a <code><a title="ki" href="#ki">ki</a></code> repository in our home
directory, just like we did in the <a href="#getting-started">getting started</a> section,
and we want to add a collaborative deck from GitHub to our collection. Let's
walk through an example. Our home directory looks like this:</p>
<pre><code class="language-bash">lyra@oxford:~$ ls
collection  pkgs
</code></pre>
<p>And we see the repo we cloned, which is called <code>collection</code>.</p>
<p>To add a collaborative deck repo as a submodule, we'll first need to change
directories to the newly cloned <code><a title="ki" href="#ki">ki</a></code> repo:</p>
<pre><code class="language-bash">lyra@oxford:~$ cd collection/
lyra@oxford:~/collection$ ls --classify
algebras/ groups/ rings/
</code></pre>
<p>We see that we have three directories, which represent three Anki decks. This
is just an example; you'll see directories corresponding to the top-level decks
in your Anki collection.</p>
<blockquote>
<p><strong>Note.</strong> The <code>ls --classify</code> command adds a trailing <code>/</code> to the end of
directories to distinguish them from ordinary files.</p>
</blockquote>
<h3 id="adding-the-repository-as-a-git-submodule">Adding the repository as a git submodule</h3>
<p>Suppose we want to add the collaborative deck
<a href="https://github.com/langfield/manifolds.git">https://github.com/langfield/manifolds.git</a>
to our collection. We can do that by running the command:</p>
<pre><code class="language-bash">git-submodule add https://github.com/langfield/manifolds.git
</code></pre>
<p>which yields the output:</p>
<pre><code class="language-bash">lyra@oxford~/collection$ git-submodule add https://github.com/langfield/manifolds.git
Cloning into 'manifolds'...
remote: Counting objects: 11, done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 11 (delta 0), reused 11 (delta 0)
Unpacking objects: 100% (11/11), done.
Checking connectivity... done.
</code></pre>
<p>And we can see that the command was successful because we have a new
directory/deck called <code>manifolds</code> in our repo:</p>
<pre><code class="language-bash">lyra@oxford:~/collection$ ls --classify
algebras/ groups/ manifolds/ rings/
</code></pre>
<p>Nice!</p>
<h2 id="editing-a-collaborative-deck">Editing a collaborative deck</h2>
<p>There are two ways to edit a collaborative deck locally:</p>
<ol>
<li>Edit the markdown files in the <code><a title="ki" href="#ki">ki</a></code> repository.</li>
<li>Edit the deck inside the Anki desktop client.</li>
</ol>
<hr>
<p>After we've cloned the <code>manifolds</code> deck repository into a submodule of our <code><a title="ki" href="#ki">ki</a></code>
repository, we may want to make some edits to the deck.</p>
<h1 id="how-it-works">How it works</h1>
<p><code><a title="ki" href="#ki">ki</a></code> is built on top of existing tooling implemented in the python package
<a href="https://github.com/lervag/apy"><code>apy</code></a>, which is used to parse the Anki
collection SQLite file and convert its contents to human-readable markdown
files.</p>
<p>These files (one per Anki note) are then dumped to a configurable location in
the filesystem as a git repository, whose structure mirrors that of the decks
in the collection. In effect, <code><a title="ki" href="#ki">ki</a></code> treats the git repo it generates as a local
copy of the collection, and the <code>.anki2</code> collection file as a remote.</p>
<p>All operations like pulling updates to the collection into <code><a title="ki" href="#ki">ki</a></code> and pushing
updates from <code><a title="ki" href="#ki">ki</a></code> into Anki are handled by git under the hood.</p>
<p>This appproach has several advantages:</p>
<ol>
<li>Merge conflicts can be handled in the usual, familiar way.</li>
<li>Additional remotes (e.g. a human-readable backup of a collection on github)
can be added easily.</li>
<li>Users are free to pick the editor of their choice, perform batch editing
with command line tools like <code>awk</code> or <code>sed</code>, and even add CI actions.</li>
</ol>
<h1 id="model">Model</h1>
<p>The following diagram shows the dataflow of a typical Anki/<code><a title="ki" href="#ki">ki</a></code> stack.</p>
<pre><code>                 +-------------+          +--------------+
                 |             |          |              |
                 |   AnkiWeb  -------------  AnkiMobile  |
                 |             |   sync   |              |
                 +------|------+          +--------------+
                        |
                        | sync
                        |
                 +------|------+
                 |             |
                 |    Anki     |
                 |             |
                 +------|------+
                        |
                        | deck edits
                        |
               +--------|--------+               +------------------+
               |                 |    ki clone   |                  |
               |                 ----------------&gt;                  |
               | Collection file |               |     ~/decks/     |
               |    (.anki2)     |    ki push    | (git repository) |
               |                 &lt;----------------                  |
               |                 |               |                  |
               +--------|--------+               +---------^--------+
                        |                                  |
                        | ki pull                          |
                        |                                  |
                        |                                  |
             +----------v----------+                       |
             |                     |                       |
             | /tmp/ki/remote/AAA  |           ki pull     |
             |  (git repository)   -------------------------
             |    [ephemeral]      |
             |                     |
             +---------------------+
</code></pre>
<p>The node labeled Anki is the Anki desktop client on the localhost. It
communicates with the AnkiWeb servers via Anki's sync feature. Other clients
(e.g. AnkiDroid and AnkiMobile) are able to (1) pull changes made by the
desktop client into their local collections via AnkiWeb, and (2) push changes
made locally back to AnkiWeb.</p>
<p>When the Anki desktop client is started on the localhost, it opens and places a
lock on the <code>.anki2</code> SQLite file. During the session, changes are possibly made
to the deck, and the SQLite file is unlocked when the program is closed.</p>
<p>Since <code><a title="ki" href="#ki">ki</a></code> must read from this database file, that means that <code><a title="ki" href="#ki">ki</a></code> commands
will not work while Anki is running. This is <strong>by design</strong>: the database is
locked for a reason, and enforcing this constraint lowers the likelihood that
users' decks become corrupted.</p>
<p>An ephemeral repository is used as an auxiliary step during the <code><a title="ki" href="#ki">ki</a> pull</code>
operation so that we can merge the Anki desktop client's changes into our
repository via git.</p>
<h1 id="generating-html">Generating html</h1>
<p>By default, <code><a title="ki" href="#ki">ki</a></code> parses the html of each field and dumps the content only,
insofar as that is possible. It also supports parsing arbitrary html elements
autogenerated by addons and regenerated the updated content. In the following
subsection, we walk through an example.</p>
<h2 id="example-generating-syntax-highlighted-code-blocks">Example: generating syntax-highlighted code blocks</h2>
<p>The anki addon developer Glutanimate has an addon called <code>syntax-highlighting</code>,
which adds UI elements to the Anki note editor that automatically generates a
syntax highlighted version of a code block from the clipboard. In effect, it
generates a formatted HTML table for the code listing that gets dumped into the
source of relevant note field.</p>
<p>A fork of this addon for the latest version of Anki (2.1.49 at the time of
writing), is available here:
<a href="https://ankiweb.net/shared/info/1972239816">https://ankiweb.net/shared/info/1972239816</a></p>
<p>And the source tree for the original addon is on github:
<a href="https://github.com/glutanimate/syntax-highlighting">https://github.com/glutanimate/syntax-highlighting</a></p>
<p>For example, consider the following python code block:</p>
<pre><code class="language-python">n = 1
n &gt;&gt; 1
print(n)
</code></pre>
<p>Given the above code, the addon generates the following HTML:</p>
<pre><code class="language-html">&lt;table class=&quot;highlighttable&quot;&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;td class=&quot;linenos&quot;&gt;
                &lt;div class=&quot;linenodiv&quot;&gt;
                    &lt;pre&gt;
                        &lt;span class=&quot;normal&quot;&gt;1&lt;/span&gt;
                        &lt;span class=&quot;normal&quot;&gt;2&lt;/span&gt;
                        &lt;span class=&quot;normal&quot;&gt;3&lt;/span&gt;
                    &lt;/pre&gt;
                &lt;/div&gt;
            &lt;/td&gt;
            &lt;td class=&quot;code&quot;&gt;
                &lt;div class=&quot;highlight&quot;&gt;
                    &lt;pre&gt;
                        &lt;code&gt;
                            &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;
                            &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
                            &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
                            &lt;br&gt;
                                &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;
                                &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;
                                &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
                                &lt;br&gt;
                                    &lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;
                                    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
                                    &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;
                                    &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                                    &lt;br&gt;
                                    &lt;/code&gt;
                                &lt;/pre&gt;
                &lt;/div&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;
</code></pre>
<p>Editing fields like this could become annoying very quickly. It would be better
if <code><a title="ki" href="#ki">ki</a></code> just gave us the markdown version above (only 3 lines), and then
regenerated the note field HTML when converting the repository back into a
<code>.anki2</code> deck.</p>
<h3 id="adding-ki-html-attributes">Adding <code><a title="ki" href="#ki">ki</a></code> HTML attributes</h3>
<p>And in fact, this is possible. We first fork the addon so we can add some extra
data to our generated HTML. In particular, we'd like to add an attribute
<code>ki-src</code> whose value is the UTF-8 encoded source code. In general, this will be
the encoded version of the source of whatever we'd like to autoformat.</p>
<p>We also add a <code>ki-formatter</code> attribute, whose value is an identifier that
specifies a custom python module (we must implement this) that transforms the
(possibly edited) <code>ki-src</code> text back into a HTML element of the form seen
above.</p>
<p>So let's call our <code>ki-formatter</code> identifier <code>syntax-hl-python</code>. Then our addon
has to change the opening tag of the snippet above to look like:</p>
<pre><code class="language-html">&lt;table class=&quot;highlighttable&quot;; ki-src=&quot;n = 1\nn &gt;&gt; 1\nprint(n)\n&quot;; ki-formatter=&quot;syntax-hl-python&quot;&gt;
</code></pre>
<p>All <code><a title="ki" href="#ki">ki</a></code> needs is the original text of the code block prior to html formatting,
and a function that can reapply the formatting to the modified text. Since the
html table was generated by an addon, we already have a python function for
this, and in general we can provide a <code>~/.config/ki/ki.json</code> file that maps
implementation IDs to paths of python modules. The module must have a top-level
function defined of the form <code>format(text: str) -&gt; bs4.Tag</code>.</p>
<p>If we have an addon implementation, we can import it here and use it in our
<code>format()</code> implementation. We can add a <code><a title="ki" href="#ki">ki</a></code> attribute whose value is the
base64 encoding of the code block, and a <code>implementation</code> attribute whose value
is the name of a function. At import-time, <code><a title="ki" href="#ki">ki</a></code> will decode this and write the
human-readable source to the relevant markdown file instead.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
&#34;&#34;&#34;
Python package `ki` is a command-line interface for the version control and
editing of `.anki2` collections as git repositories of markdown files.
Rather than providing an interactive UI like the Anki desktop client, `ki` aims
to allow natural editing *in the filesystem*.

In general, the purpose of `ki` is to allow users to work on large, complex
Anki decks in exactly the same way they work on large, complex software
projects.
.. include:: ./DOCUMENTATION.md
&#34;&#34;&#34;

# pylint: disable=invalid-name, missing-class-docstring, broad-except
# pylint: disable=too-many-return-statements, too-many-lines

import os
import re
import json
import copy
import shutil
import logging
import secrets
import hashlib
import sqlite3
import tempfile
import functools
import subprocess
import unicodedata
import configparser
from enum import Enum
from pathlib import Path
from dataclasses import dataclass

import git
import click
import markdownify
import prettyprinter as pp
from tqdm import tqdm
from lark import Lark
from loguru import logger
from result import Result, Err, Ok, OkErr

import anki
from anki import notetypes_pb2
from anki.collection import Collection, Note, OpChangesWithId

from apy.convert import markdown_to_html, plain_to_html, html_to_markdown

from beartype import beartype
from beartype.typing import (
    Set,
    List,
    Dict,
    Any,
    Optional,
    Union,
    Tuple,
    Generator,
    Callable,
)

import ki.maybes as M
import ki.functional as F
from ki.monadic import monadic
from ki.types import (
    MODELS_FILE,
    ExtantFile,
    ExtantDir,
    EmptyDir,
    NoPath,
    Singleton,
    ExtantStrangePath,
    GitChangeType,
    Delta,
    KiRepo,
    Field,
    Template,
    Notetype,
    ColNote,
    KiRepoRef,
    RepoRef,
    Leaves,
    MissingFileError,
    MissingDirectoryError,
    ExpectedFileButGotDirectoryError,
    ExpectedDirectoryButGotFileError,
    ExpectedEmptyDirectoryButGotNonEmptyDirectoryError,
    StrangeExtantPathError,
    NotKiRepoError,
    UpdatesRejectedError,
    TargetExistsError,
    GitRefNotFoundError,
    CollectionChecksumError,
    MissingNotetypeError,
    MissingFieldOrdinalError,
    MissingNoteIdError,
    NotetypeMismatchError,
    NoteFieldValidationWarning,
    UnhealthyNoteWarning,
)
from ki.transformer import NoteTransformer, FlatNote

logging.basicConfig(level=logging.INFO)

ChangeNotetypeInfo = notetypes_pb2.ChangeNotetypeInfo
ChangeNotetypeRequest = notetypes_pb2.ChangeNotetypeRequest
NotetypeDict = Dict[str, Any]

# Type alias for OkErr types. Subscript indicates the Ok type.
Res = List

FS_ROOT = Path(&#34;/&#34;)

GIT = &#34;.git&#34;
GITIGNORE_FILE = &#34;.gitignore&#34;
GITMODULES_FILE = &#34;.gitmodules&#34;

KI = &#34;.ki&#34;
CONFIG_FILE = &#34;config&#34;
HASHES_FILE = &#34;hashes&#34;
BACKUPS_DIR = &#34;backups&#34;
LAST_PUSH_FILE = &#34;last_push&#34;
NO_SM_DIR = &#34;no_submodules_tree&#34;

BATCH_SIZE = 500
HTML_REGEX = r&#34;&lt;/?\s*[a-z-][^&gt;]*\s*&gt;|(\&amp;(?:[\w\d]+|#\d+|#x[a-f\d]+);)&#34;
REMOTE_NAME = &#34;anki&#34;
BRANCH_NAME = &#34;main&#34;
CHANGE_TYPES = &#34;A D R M T&#34;.split()
TQDM_NUM_COLS = 70
MAX_FIELNAME_LEN = 30
HINT = (
    &#34;hint: Updates were rejected because the tip of your current branch is behind\n&#34;
    + &#34;hint: the Anki remote collection. Integrate the remote changes (e.g.\n&#34;
    + &#34;hint: &#39;ki pull ...&#39;) before pushing again.&#34;
)
IGNORE = [GIT, KI, GITIGNORE_FILE, GITMODULES_FILE, MODELS_FILE]
LOCAL_SUFFIX = Path(&#34;ki/local&#34;)
STAGE_SUFFIX = Path(&#34;ki/stage&#34;)
REMOTE_SUFFIX = Path(&#34;ki/remote&#34;)
DELETED_SUFFIX = Path(&#34;ki/deleted&#34;)
FIELD_HTML_SUFFIX = Path(&#34;ki/fieldhtml&#34;)

REMOTE_CONFIG_SECTION = &#34;remote&#34;
COLLECTION_FILE_PATH_CONFIG_FIELD = &#34;path&#34;

GENERATED_HTML_SENTINEL = &#34;data-original-markdown&#34;

MD = &#34;.md&#34;


# TODO: Should catch exception and transform into nice Err that tells user what to do.
@beartype
def lock(kirepo: KiRepo) -&gt; sqlite3.Connection:
    &#34;&#34;&#34;Acquire a lock on a SQLite3 database given a path.&#34;&#34;&#34;
    con = sqlite3.connect(kirepo.col_file)
    con.isolation_level = &#34;EXCLUSIVE&#34;
    con.execute(&#34;BEGIN EXCLUSIVE&#34;)
    return con


@beartype
def unlock(con: sqlite3.Connection) -&gt; bool:
    &#34;&#34;&#34;Unlock a SQLite3 database.&#34;&#34;&#34;
    con.commit()
    con.close()
    return True


@monadic
@beartype
def get_ephemeral_repo(
    suffix: Path, repo_ref: RepoRef, md5sum: str
) -&gt; Result[git.Repo, Exception]:
    &#34;&#34;&#34;Get a temporary copy of a git repository in /tmp/&lt;suffix&gt;/.&#34;&#34;&#34;
    tempdir: EmptyDir = F.mkdtemp()
    root: EmptyDir = F.mksubdir(tempdir, suffix)

    # Git clone `repo` at latest commit in `/tmp/.../&lt;suffix&gt;/&lt;md5sum&gt;`.
    repo: git.Repo = repo_ref.repo
    branch = repo.active_branch
    target: Path = root / md5sum

    # UNSAFE: But only called here, and it should be guaranteed to work because
    # `repo` is actually a git repository, presumably there is always an
    # active branch, and `target` does not exist.
    ephem = git.Repo.clone_from(repo.working_dir, target, branch=branch, recursive=True)

    # Do a reset --hard to the given SHA.
    ephem.git.reset(repo_ref.sha, hard=True)

    return Ok(ephem)


@monadic
@beartype
def get_ephemeral_kirepo(
    suffix: Path, kirepo_ref: KiRepoRef, md5sum: str
) -&gt; Result[KiRepo, Exception]:
    &#34;&#34;&#34;
    Given a KiRepoRef, i.e. a pair of the form (kirepo, SHA), we clone
    `kirepo.repo` into a temp directory and hard reset to the given commit
    hash.

    Parameters
    ----------
    suffix : pathlib.Path
        /tmp/.../ path suffix, e.g. `ki/local/`.
    kirepo_ref : KiRepoRef
        The ki repository to clone, and a commit for it.
    md5sum : str
        The md5sum of the associated anki collection.

    Returns
    -------
    KiRepo
        The cloned repository.
    &#34;&#34;&#34;
    ref: Res[RepoRef] = M.repo_ref(kirepo_ref.kirepo.repo, kirepo_ref.sha)
    ephem: Res[git.Repo] = get_ephemeral_repo(suffix, ref, md5sum)
    if ephem.is_err():
        return ephem
    ephem: git.Repo = ephem.unwrap()
    ephem_ki_dir: OkErr = M.nopath(Path(ephem.working_dir) / KI)
    if ephem_ki_dir.is_err():
        return ephem_ki_dir
    ephem_ki_dir: NoPath = ephem_ki_dir.unwrap()
    F.copytree(kirepo_ref.kirepo.ki_dir, ephem_ki_dir)
    kirepo: Res[KiRepo] = M.kirepo(F.working_dir(ephem))

    return kirepo


@beartype
def is_anki_note(path: ExtantFile) -&gt; bool:
    &#34;&#34;&#34;Check if file is an `apy`-style markdown anki note.&#34;&#34;&#34;
    path = str(path)

    # Ought to have markdown file extension.
    if path[-3:] != &#34;.md&#34;:
        return False
    with open(path, &#34;r&#34;, encoding=&#34;UTF-8&#34;) as md_f:
        lines = md_f.readlines()
    if len(lines) &lt; 2:
        return False
    if lines[0] != &#34;## Note\n&#34;:
        return False
    if not re.match(r&#34;^nid: [0-9]+$&#34;, lines[1]):
        return False
    return True


@beartype
def filter_note_path(path: Path, patterns: List[str], root: ExtantDir) -&gt; bool:
    &#34;&#34;&#34;Lambda to be used as first argument to filter(). Filters out paths-to-ignore.&#34;&#34;&#34;
    for p in patterns:
        if p == path.name:
            logger.warning(f&#34;Ignoring {path} matching pattern {p}&#34;)
            return False

    # Ignore files that match a pattern in `patterns` (&#39;*&#39; not supported).
    for ignore_path in [root / p for p in patterns]:
        parents = [path.resolve()] + [p.resolve() for p in path.parents]
        if ignore_path.resolve() in parents:
            logger.warning(f&#34;Ignoring {path} matching pattern {ignore_path}&#34;)
            return False

    # If `path` is an extant file (not a directory) and NOT a note, ignore it.
    if path.exists() and path.resolve().is_file():
        file = ExtantFile(path.resolve())
        if not is_anki_note(file):
            logger.warning(f&#34;Not Anki note {file}&#34;)
            return False

    return True


@beartype
def unsubmodule_repo(repo: git.Repo) -&gt; None:
    &#34;&#34;&#34;
    Un-submodule all the git submodules (convert to ordinary subdirectories and
    destroy commit history).

    MUTATES REPO in-place!

    UNSAFE: git.rm() calls.
    &#34;&#34;&#34;
    gitmodules_path: Path = Path(repo.working_dir) / GITMODULES_FILE
    for sm in repo.submodules:

        # Untrack, remove gitmodules file, remove .git file, and add directory back.
        sm.update()

        # Guaranteed to exist by gitpython.
        sm_path = Path(sm.module().working_tree_dir)
        repo.git.rm(sm_path, cached=True)

        # May not exist.
        repo.git.rm(gitmodules_path)

        # Guaranteed to exist by gitpython, and safe because we pass
        # `missing_ok=True`, which means no error is raised.
        (sm_path / GIT).unlink(missing_ok=True)

        # Should still exist after git.rm().
        repo.git.add(sm_path)
        _ = repo.index.commit(f&#34;Add submodule {sm.name} as ordinary directory.&#34;)

    if gitmodules_path.exists():
        repo.git.rm(gitmodules_path)
        _ = repo.index.commit(&#34;Remove &#39;.gitmodules&#39; file.&#34;)


@monadic
@beartype
def diff_repos(
    a_repo: git.Repo,
    b_repo: git.Repo,
    ref: RepoRef,
    filter_fn: Callable[[Path], bool],
    parser: Lark,
    transformer: NoteTransformer,
) -&gt; Result[List[Delta], Exception]:
    # Use a `DiffIndex` to get the changed files.
    deltas = []
    a_dir = Path(a_repo.working_dir)
    b_dir = Path(b_repo.working_dir)
    logger.debug(f&#34;Diffing {ref.sha} against {b_repo.head.commit.hexsha}&#34;)
    diff_index = b_repo.commit(ref.sha).diff(b_repo.head.commit)
    for change_type in GitChangeType:
        for diff in diff_index.iter_change_type(change_type.value):

            if not filter_fn(a_dir / diff.a_path) or not filter_fn(a_dir / diff.b_path):
                logger.warning(f&#34;Ignoring:\n{diff.a_path}\n{diff.b_path}&#34;)
                continue

            a_path = F.test(a_dir / diff.a_path)
            b_path = F.test(b_dir / diff.b_path)

            a_relpath = Path(diff.a_path)
            b_relpath = Path(diff.b_path)

            if change_type == GitChangeType.DELETED:
                if not isinstance(a_path, ExtantFile):
                    logger.warning(f&#34;Deleted file not found in source commit: {a_path}&#34;)
                    continue

                deltas.append(Delta(change_type, a_path, a_relpath))
                continue

            if not isinstance(b_path, ExtantFile):
                logger.warning(f&#34;Diff target not found: {b_path}&#34;)
                continue

            if change_type == GitChangeType.RENAMED:
                a_flatnote: FlatNote = parse_markdown_note(parser, transformer, a_path)
                b_flatnote: FlatNote = parse_markdown_note(parser, transformer, b_path)
                if a_flatnote.nid != b_flatnote.nid:
                    logger.debug(f&#34;Adding delta: {change_type} {a_path} {b_path}&#34;)
                    deltas.append(Delta(GitChangeType.DELETED, a_path, a_relpath))
                    deltas.append(Delta(GitChangeType.ADDED, b_path, b_relpath))
                    continue

            logger.debug(f&#34;Adding delta: {change_type} {b_path}&#34;)
            deltas.append(Delta(change_type, b_path, b_relpath))

    return Ok(deltas)


@beartype
def parse_notetype_dict(nt: Dict[str, Any]) -&gt; Result[Notetype, Exception]:
    &#34;&#34;&#34;
    Convert an Anki NotetypeDict into a Notetype dataclass.

    Anki returns objects of type `NotetypeDict` (see pylib/anki/models.py)
    when you call a method like `col.models.all()`. This is a dictionary
    mapping strings to various stuff, and we read all its data into a python
    dataclass here so that we can access it safely. Since we don&#39;t expect Anki
    to ever give us &#39;invalid&#39; notetypes (since we define &#39;valid&#39; as being
    processable by Anki), we return an exception if the parse fails.

    Note on naming convention: Below, abbreviated variable names represent
    dicts coming from Anki, like `nt: NotetypeDict` or `fld: FieldDict`.
    Full words like `field: Field` represent ki dataclasses. The parameters
    of the dataclasses, however, use abbreviations for consistency with Anki
    map keys.
    &#34;&#34;&#34;
    try:
        fields: Dict[int, Field] = {}
        for fld in nt[&#34;flds&#34;]:
            ordinal = fld[&#34;ord&#34;]
            fields[ordinal] = Field(name=fld[&#34;name&#34;], ord=ordinal)

        templates: List[Template] = []
        for tmpl in nt[&#34;tmpls&#34;]:
            templates.append(
                Template(
                    name=tmpl[&#34;name&#34;],
                    qfmt=tmpl[&#34;qfmt&#34;],
                    afmt=tmpl[&#34;afmt&#34;],
                    ord=tmpl[&#34;ord&#34;],
                )
            )

        # Guarantee that &#39;sortf&#39; exists in `notetype.flds`.
        sort_ordinal: int = nt[&#34;sortf&#34;]
        if sort_ordinal not in fields:
            return Err(MissingFieldOrdinalError)

        notetype = Notetype(
            id=nt[&#34;id&#34;],
            name=nt[&#34;name&#34;],
            type=nt[&#34;type&#34;],
            flds=list(fields.values()),
            tmpls=templates,
            sortf=fields[sort_ordinal],
            dict=copy.deepcopy(nt),
        )

    except KeyError as err:
        return Err(err)
    return Ok(notetype)


@monadic
@beartype
def get_models_recursively(kirepo: KiRepo) -&gt; Result[Dict[str, Notetype], Exception]:
    &#34;&#34;&#34;
    Find and merge all `models.json` files recursively.

    Should we check for duplicates?

    Returns
    -------
    Result[Dict[int, Notetype], Exception]
        A result.Result that returns a dictionary sending model names to
        Notetypes.
    &#34;&#34;&#34;
    all_models: Dict[str, Notetype] = {}

    # Load notetypes from json files.
    for models_file in F.rglob(kirepo.root, MODELS_FILE):
        with open(models_file, &#34;r&#34;, encoding=&#34;UTF-8&#34;) as models_f:
            models: Dict[str, Notetype] = {}
            new_nts: Dict[int, Dict[str, Any]] = json.load(models_f)
            for _, nt in new_nts.items():
                parsed = parse_notetype_dict(nt)
                if parsed.is_err():
                    return parsed
                notetype: Notetype = parsed.ok()
                models[notetype.name] = notetype

        # Add mappings to dictionary.
        all_models.update(models)

    return Ok(all_models)


@beartype
def display_fields_health_warning(note: anki.notes.Note) -&gt; int:
    &#34;&#34;&#34;Display warnings when Anki&#39;s fields health check fails.&#34;&#34;&#34;
    health = note.fields_check()
    if health == 1:
        logger.warning(f&#34;Found empty note:\n {note}&#34;)
        logger.warning(f&#34;Fields health check code: {health}&#34;)
    elif health == 2:
        logger.warning(f&#34;\nFound duplicate note when adding new note w/ nid {note.id}.&#34;)
        logger.warning(f&#34;Notetype/fields of note {note.id} match existing note.&#34;)
        logger.warning(&#34;Note was not added to collection!&#34;)
        logger.warning(f&#34;First field: {note.fields[0]}&#34;)
        logger.warning(f&#34;Fields health check code: {health}&#34;)
    elif health != 0:
        logger.error(f&#34;Failed to process note &#39;{note.id}&#39;.&#34;)
        logger.error(f&#34;Note failed fields check with unknown error code: {health}&#34;)
    return health


@beartype
def parse_markdown_note(
    parser: Lark, transformer: NoteTransformer, notes_file: ExtantFile
) -&gt; FlatNote:
    &#34;&#34;&#34;Parse with lark.&#34;&#34;&#34;
    tree = parser.parse(notes_file.read_text(encoding=&#34;UTF-8&#34;))
    flatnotes: List[FlatNote] = transformer.transform(tree)

    # UNSAFE!
    return flatnotes[0]


@monadic
@beartype
def update_note(
    note: Note, flatnote: FlatNote, old_notetype: Notetype, new_notetype: Notetype
) -&gt; Result[Note, Exception]:
    &#34;&#34;&#34;
    Change all the data of `note` to that given in `flatnote`.

    This is only to be called on notes whose nid already exists in the
    database.  Creates a new deck if `flatnote.deck` doesn&#39;t exist.  Assumes
    that the model has already been added to the collection, and raises an
    exception if it finds otherwise.  Changes notetype to that specified by
    `flatnote.model`.  Overwrites all fields with `flatnote.fields`.

    Updates:
    - tags
    - deck
    - model
    - fields
    &#34;&#34;&#34;

    # Check that the passed argument `new_notetype` has a name consistent with
    # the model specified in `flatnote`. The former should be derived from the
    # latter, and if they don&#39;t match, there is a bug in the caller.
    if flatnote.model != new_notetype.name:
        return Err(NotetypeMismatchError(flatnote, new_notetype))

    note.tags = flatnote.tags
    note.flush()

    # Set the deck of the given note, and create a deck with this name if it
    # doesn&#39;t already exist. See the comments/docstrings in the implementation.
    newdid: int = note.col.decks.id(flatnote.deck, create=True)
    cids = [c.id for c in note.cards()]

    # Set deck for all cards of this note.
    if cids:
        note.col.set_deck(cids, newdid)

    # Change notetype of note.
    fmap: Dict[str, None] = {}
    for field in old_notetype.flds:
        fmap[field.ord] = None
    note.col.models.change(old_notetype.dict, [note.id], new_notetype.dict, fmap, None)
    note.load()

    # Validate field keys against notetype.
    validated: OkErr = validate_flatnote_fields(new_notetype, flatnote)
    if validated.is_err():
        # TODO: Decide where warnings should be printed.
        logger.warning(validated.err())
        return validated

    # Set field values. This is correct because every field name that appears
    # in `new_notetype` is contained in `flatnote.fields`, or else we would
    # have printed a warning and returned above.
    # TODO: Check if these apy methods can raise exceptions.
    for key, field in flatnote.fields.items():
        if flatnote.markdown:
            note[key] = markdown_to_html(field)
        else:
            note[key] = plain_to_html(field)

    # Flush fields to collection object.
    note.flush()

    # Remove if unhealthy.
    health = display_fields_health_warning(note)
    if health != 0:
        note.col.remove_notes([note.id])
        return Err(UnhealthyNoteWarning(str(note.id)))

    return Ok(note)


@monadic
@beartype
def validate_flatnote_fields(
    notetype: Notetype, flatnote: FlatNote
) -&gt; Result[bool, Warning]:
    &#34;&#34;&#34;Validate that the fields given in the note match the notetype.&#34;&#34;&#34;
    # Set current notetype for collection to `model_name`.
    field_names: List[str] = [field.name for field in notetype.flds]

    # TODO: Use a more descriptive error message.
    if len(flatnote.fields.keys()) != len(field_names):
        msg = f&#34;Wrong number of fields for model {flatnote.model}!&#34;
        return Err(NoteFieldValidationWarning(msg))

    for x, y in zip(field_names, flatnote.fields.keys()):
        if x != y:
            msg = f&#34;Inconsistent field names ({x} != {y})&#34;
            return Err(NoteFieldValidationWarning(msg))
    return Ok()


@beartype
def get_note_path(sort_field_text: str, deck_dir: ExtantDir) -&gt; ExtantFile:
    &#34;&#34;&#34;Get note path from sort field text.&#34;&#34;&#34;
    field_text = sort_field_text

    # Construct filename, stripping HTML tags and sanitizing (quickly).
    field_text = plain_to_html(field_text)
    field_text = re.sub(&#34;&lt;[^&lt;]+?&gt;&#34;, &#34;&#34;, field_text)

    # If the HTML stripping removed all text, we just slugify the raw sort
    # field text.
    if len(field_text) == 0:
        field_text = sort_field_text

    name = field_text[:MAX_FIELNAME_LEN]
    slug = F.slugify(name, allow_unicode=True)

    # Make it so `slug` cannot possibly be an empty string, because then we get
    # a `Path(&#39;.&#39;)` which is a bug, and causes a runtime exception.  If all
    # else fails, generate a random hex string to use as the filename.
    if len(slug) == 0:
        slug = secrets.token_hex(10)
        logger.warning(f&#34;Slug for {name} is empty. Using {slug} as filename&#34;)

    filename = Path(slug)
    filename = filename.with_suffix(MD)
    note_path = F.test(deck_dir / filename)

    i = 1
    while not isinstance(note_path, NoPath):
        filename = Path(f&#34;{name}_{i}&#34;).with_suffix(MD)
        note_path = F.test(deck_dir / filename)
        i += 1

    note_path: ExtantFile = F.touch(deck_dir, str(filename))

    return note_path


@beartype
def backup(kirepo: KiRepo) -&gt; None:
    &#34;&#34;&#34;Backup collection to `.ki/backups`.&#34;&#34;&#34;
    md5sum = F.md5(kirepo.col_file)
    name = f&#34;{md5sum}.anki2&#34;
    backup_file = F.test(kirepo.backups_dir / name)

    # We assume here that no one would ever make e.g. a directory called
    # `name`, since `name` contains the md5sum of the collection file, and
    # thus that is extraordinarily improbable. So the only thing we have to
    # check for is that we haven&#39;t already written a backup file to this
    # location.
    if isinstance(backup_file, ExtantFile):
        echo(&#34;Backup already exists.&#34;)
        return

    echo(f&#34;Writing backup of .anki2 file to &#39;{backup_file}&#39;&#34;)
    F.copyfile(kirepo.col_file, kirepo.backups_dir, name)


@beartype
def append_md5sum(
    ki_dir: ExtantDir, tag: str, md5sum: str, silent: bool = False
) -&gt; None:
    &#34;&#34;&#34;Append an md5sum hash to the hashes file.&#34;&#34;&#34;
    hashes_file = ki_dir / HASHES_FILE
    with open(hashes_file, &#34;a+&#34;, encoding=&#34;UTF-8&#34;) as hashes_f:
        hashes_f.write(f&#34;{md5sum}  {tag}\n&#34;)
    echo(f&#34;Wrote md5sum to &#39;{hashes_file}&#39;&#34;, silent)


@beartype
def create_deck_dir(deck_name: str, targetdir: ExtantDir) -&gt; ExtantDir:
    &#34;&#34;&#34;Construct path to deck directory and create it.&#34;&#34;&#34;
    # Strip leading periods so we don&#39;t get hidden folders.
    components = deck_name.split(&#34;::&#34;)
    components = [re.sub(r&#34;^\.&#34;, r&#34;&#34;, comp) for comp in components]
    deck_path = Path(targetdir, *components)
    return F.force_mkdir(deck_path)


@beartype
def get_field_note_id(nid: int, fieldname: str) -&gt; str:
    &#34;&#34;&#34;A str ID that uniquely identifies field-note pairs.&#34;&#34;&#34;
    return f&#34;{nid}{F.slugify(fieldname, allow_unicode=True)}&#34;


@monadic
@beartype
def push_flatnote_to_anki(
    col: Collection, flatnote: FlatNote
) -&gt; Result[ColNote, Exception]:
    model_id: Optional[int] = col.models.id_for_name(flatnote.model)
    if model_id is None:
        return Err(MissingNotetypeError(flatnote.model))

    new = False
    note: Note
    try:
        note = col.get_note(flatnote.nid)
    except anki.errors.NotFoundError:
        logger.debug(f&#34;Failed to find &#39;{flatnote.nid}&#39;&#34;)
        note = col.new_note(model_id)
        col.add_note(note, col.decks.id(flatnote.deck, create=True))
        logger.debug(f&#34;Got new nid &#39;{note.id}&#39;&#34;)
        new = True

    old_notetype: Res[Notetype] = parse_notetype_dict(note.note_type())
    new_notetype: Res[Notetype] = parse_notetype_dict(col.models.get(model_id))

    note: OkErr = update_note(note, flatnote, old_notetype, new_notetype)
    if note.is_err():
        return note

    note: Note = note.unwrap()
    new_notetype: Notetype = new_notetype.unwrap()

    # Get sort field content.
    try:
        sortf_text: str = note[new_notetype.sortf.name]
    except KeyError as err:
        return Err(err)

    colnote = ColNote(
        n=note,
        new=new,
        deck=flatnote.deck,
        title=flatnote.title,
        old_nid=flatnote.nid,
        markdown=flatnote.markdown,
        notetype=new_notetype,
        sortf_text=sortf_text,
    )
    return Ok(colnote)


@beartype
def get_colnote(col: Collection, nid: int) -&gt; Result[ColNote, Exception]:
    try:
        note = col.get_note(nid)
    except anki.errors.NotFoundError:
        return Err(MissingNoteIdError(nid))
    notetype: OkErr = parse_notetype_dict(note.note_type())
    if notetype.is_err():
        return notetype
    notetype: Notetype = notetype.unwrap()

    # Get sort field content.
    try:
        sortf_text: str = note[notetype.sortf.name]
    except KeyError as err:
        return Err(err)

    # TODO: Remove implicit assumption that all cards are in the same deck, and
    # work with cards instead of notes.
    deck = col.decks.name(note.cards()[0].did)
    colnote = ColNote(
        n=note,
        new=False,
        deck=deck,
        title=&#34;&#34;,
        old_nid=note.id,
        markdown=False,
        notetype=notetype,
        sortf_text=sortf_text,
    )
    return Ok(colnote)


@beartype
def get_header_lines(colnote) -&gt; List[str]:
    &#34;&#34;&#34;Get header of markdown representation of note.&#34;&#34;&#34;
    lines = [
        &#34;## Note&#34;,
        f&#34;nid: {colnote.n.id}&#34;,
        f&#34;model: {colnote.notetype.name}&#34;,
    ]

    lines += [f&#34;deck: {colnote.deck}&#34;]
    lines += [f&#34;tags: {&#39;, &#39;.join(colnote.n.tags)}&#34;]

    if not any(GENERATED_HTML_SENTINEL in field for field in colnote.n.values()):
        lines += [&#34;markdown: false&#34;]

    lines += [&#34;&#34;]
    return lines


@monadic
@beartype
def write_repository(
    col_file: ExtantFile, targetdir: ExtantDir, leaves: Leaves, silent: bool
) -&gt; Result[bool, Exception]:
    &#34;&#34;&#34;Write notes to appropriate directories in `targetdir`.&#34;&#34;&#34;

    # Create config file.
    config_file: ExtantFile = leaves.files[CONFIG_FILE]
    config = configparser.ConfigParser()
    config[&#34;remote&#34;] = {&#34;path&#34;: col_file}
    with open(config_file, &#34;w&#34;, encoding=&#34;UTF-8&#34;) as config_f:
        config.write(config_f)

    # Create temp directory for htmlfield text files.
    tempdir: EmptyDir = F.mkdtemp()
    root: EmptyDir = F.mksubdir(tempdir, FIELD_HTML_SUFFIX)

    paths: Dict[str, ExtantFile] = {}
    decks: Dict[str, List[ColNote]] = {}

    # Open deck with `apy`, and dump notes and markdown files.
    cwd: ExtantDir = F.cwd()
    col = Collection(col_file)
    F.chdir(cwd)

    all_nids = list(col.find_notes(query=&#34;&#34;))
    for nid in tqdm(all_nids, ncols=TQDM_NUM_COLS, disable=silent):
        colnote: OkErr = get_colnote(col, nid)
        if colnote.is_err():
            return colnote
        colnote: ColNote = colnote.unwrap()
        decks[colnote.deck] = decks.get(colnote.deck, []) + [colnote]
        for fieldname, fieldtext in colnote.n.items():
            if re.search(HTML_REGEX, fieldtext):
                fid: str = get_field_note_id(nid, fieldname)
                html_file: ExtantFile = F.touch(root, fid)
                html_file.write_text(fieldtext, encoding=&#34;UTF-8&#34;)
                paths[fid] = html_file

    # TODO: Consider adding a block in `safe()` that looks for a token
    # keyword argument, like `_err`, and bypasses the function call if it
    # is an Err. If it is an Ok, it simply removes that key-value pair from
    # `kwargs` and calls the function as it normally would.
    tidied: OkErr = tidy_html_recursively(root, silent)
    if tidied.is_err():
        return tidied
    wrote: OkErr = write_decks(col, targetdir, decks, paths)

    # Replace with frmtree.
    shutil.rmtree(root)

    return wrote


@monadic
@beartype
def write_decks(
    col: Collection,
    targetdir: ExtantDir,
    decks: Dict[str, List[ColNote]],
    paths: Dict[str, ExtantFile],
) -&gt; Result[bool, Exception]:
    &#34;&#34;&#34;
    There is a bug in &#39;write_decks()&#39;. The sorting of deck names is done by
    length, in reverse, which means we start from the deepest, most specific
    decks, and end up at the root. I.e. We are traversing up a tree from the
    leaves to the root. Previously (see earlier commits), we simply accumulated
    all model ids and wrote the entire list (so far) to each deck&#39;s model.json
    file. But this is actually wrong, because if we have two subtrees, the one
    with larger height may have its model ids end up in the other. Since we&#39;re
    sorting by string length, it&#39;s a very imprecise, wrong way to do things.
    The proper way to do this is a DFS traversal, perhaps recursively, which
    will make it easier to keep things purely functional, accumulating the
    model ids of the children in each node. For this, we must construct a tree
    from the deck names.
    &#34;&#34;&#34;
    # Accumulate pairs of model ids and notetype maps. The return type of the
    # `ModelManager.get()` call below indicates that it may return `None`,
    # but we know it will not because we are getting the notetype id straight
    # from the Anki DB.
    models_map: Dict[int, NotetypeDict] = {}
    for nt_name_id in col.models.all_names_and_ids():
        models_map[nt_name_id.id] = col.models.get(nt_name_id.id)

    # Dump the models file for the whole repository.
    with open(targetdir / MODELS_FILE, &#34;w&#34;, encoding=&#34;UTF-8&#34;) as f:
        json.dump(models_map, f, ensure_ascii=False, indent=4)

    for deck_name in sorted(set(decks.keys()), key=len, reverse=True):
        deck_dir: ExtantDir = create_deck_dir(deck_name, targetdir)
        model_ids: Set[int] = set()
        deck: List[ColNote] = decks[deck_name]
        for colnote in deck:
            model_ids.add(colnote.notetype.id)
            notepath: ExtantFile = get_note_path(colnote.sortf_text, deck_dir)
            payload: str = get_note_payload(colnote, paths)
            notepath.write_text(payload, encoding=&#34;UTF-8&#34;)

        # Write `models.json` for current deck.
        deck_models_map = {mid: models_map[mid] for mid in model_ids}
        with open(deck_dir / MODELS_FILE, &#34;w&#34;, encoding=&#34;UTF-8&#34;) as f:
            json.dump(deck_models_map, f, ensure_ascii=False, indent=4)

    return Ok()


@beartype
def html_to_screen(html: str) -&gt; str:
    &#34;&#34;&#34;Convert html for printing to screen.&#34;&#34;&#34;
    html = re.sub(r&#34;\&lt;style\&gt;.*\&lt;\/style\&gt;&#34;, &#34;&#34;, html, flags=re.S)

    generated = GENERATED_HTML_SENTINEL in html
    if generated:
        plain = html_to_markdown(html)
        if html != markdown_to_html(plain):
            html_clean = re.sub(r&#39; data-original-markdown=&#34;[^&#34;]*&#34;&#39;, &#34;&#34;, html)
            plain += (
                &#34;\n\n### Current HTML → Markdown\n&#34;
                f&#34;{markdownify.markdownify(html_clean)}&#34;
            )
            plain += f&#34;\n### Current HTML\n{html_clean}&#34;
    else:
        plain = html

    # For convenience: Un-escape some common LaTeX constructs
    plain = plain.replace(r&#34;\\\\&#34;, r&#34;\\&#34;)
    plain = plain.replace(r&#34;\\{&#34;, r&#34;\{&#34;)
    plain = plain.replace(r&#34;\\}&#34;, r&#34;\}&#34;)
    plain = plain.replace(r&#34;\*}&#34;, r&#34;*}&#34;)

    plain = plain.replace(r&#34;&amp;lt;&#34;, &#34;&lt;&#34;)
    plain = plain.replace(r&#34;&amp;gt;&#34;, &#34;&gt;&#34;)
    plain = plain.replace(r&#34;&amp;amp;&#34;, &#34;&amp;&#34;)
    plain = plain.replace(r&#34;&amp;nbsp;&#34;, &#34; &#34;)

    plain = plain.replace(&#34;&lt;br&gt;&#34;, &#34;\n&#34;)
    plain = plain.replace(&#34;&lt;br/&gt;&#34;, &#34;\n&#34;)
    plain = plain.replace(&#34;&lt;br /&gt;&#34;, &#34;\n&#34;)
    plain = plain.replace(&#34;&lt;div&gt;&#34;, &#34;\n&#34;)
    plain = plain.replace(&#34;&lt;/div&gt;&#34;, &#34;&#34;)

    # For convenience: Fix mathjax escaping (but only if the html is generated)
    if generated:
        plain = plain.replace(r&#34;\[&#34;, r&#34;[&#34;)
        plain = plain.replace(r&#34;\]&#34;, r&#34;]&#34;)
        plain = plain.replace(r&#34;\(&#34;, r&#34;(&#34;)
        plain = plain.replace(r&#34;\)&#34;, r&#34;)&#34;)

    plain = re.sub(r&#34;\&lt;b\&gt;\s*\&lt;\/b\&gt;&#34;, &#34;&#34;, plain)
    return plain.strip()


@beartype
def get_colnote_repr(colnote: ColNote) -&gt; str:
    lines = get_header_lines(colnote)
    for field_name, field_text in colnote.n.items():
        lines.append(&#34;### &#34; + field_name)
        lines.append(html_to_screen(field_text))
        lines.append(&#34;&#34;)

    return &#34;\n&#34;.join(lines)


# TODO: Come up with a better name than `paths`.
@beartype
def get_note_payload(colnote: ColNote, paths: Dict[str, ExtantFile]) -&gt; str:
    &#34;&#34;&#34;
    Return the markdown-converted contents of the Anki note represented by
    `colnote` as a string.

    Given a `ColNote`, which is a dataclass wrapper around a `Note` object
    which has been loaded from the DB, and a mapping from `fid`s (unique
    identifiers of field-note pairs) to paths, we check for each field of each
    note whether that field&#39;s `fid` is contained in `paths`. If so, that means
    that the caller dumped the contents of this field to a file (the file with
    this path, in fact) in order to autoformat the HTML source. If this field
    was tidied/autoformatted, we read from that path to get the tidied source,
    otherwise, we use the field content present in the `ColNote`.
    &#34;&#34;&#34;
    # Get tidied html if it exists.
    tidyfields = {}
    for field_name, field_text in colnote.n.items():
        fid = get_field_note_id(colnote.n.id, field_name)
        if fid in paths:
            tidyfields[field_name] = paths[fid].read_text()
        else:
            tidyfields[field_name] = field_text

    # TODO: Make this use `get_colnote_repr()`.
    # Construct note repr from tidyfields map.
    lines = get_header_lines(colnote)
    for field_name, field_text in tidyfields.items():
        lines.append(&#34;### &#34; + field_name)
        lines.append(html_to_screen(field_text))
        lines.append(&#34;&#34;)

    return &#34;\n&#34;.join(lines)


# TODO: Refactor into a safe function.
@beartype
def git_subprocess_pull(remote: str, branch: str) -&gt; int:
    &#34;&#34;&#34;Pull remote into branch using a subprocess call.&#34;&#34;&#34;
    p = subprocess.run(
        [
            &#34;git&#34;,
            &#34;pull&#34;,
            &#34;-v&#34;,
            &#34;--allow-unrelated-histories&#34;,
            &#34;--strategy-option&#34;,
            &#34;theirs&#34;,
            remote,
            branch,
        ],
        check=False,
        capture_output=True,
    )
    pull_stderr = p.stderr.decode()
    logger.debug(f&#34;\n{pull_stderr}&#34;)
    logger.debug(f&#34;Return code: {p.returncode}&#34;)
    if p.returncode != 0:
        raise ValueError(pull_stderr)
    return p.returncode


@beartype
def echo(string: str, silent: bool = False) -&gt; None:
    &#34;&#34;&#34;Call `click.secho()` with formatting.&#34;&#34;&#34;
    if not silent:
        click.secho(string, bold=True)
        # logger.info(string)


@monadic
@beartype
def tidy_html_recursively(root: ExtantDir, silent: bool) -&gt; Result[bool, Exception]:
    &#34;&#34;&#34;Call html5-tidy on each file in `root`, editing in-place.&#34;&#34;&#34;
    # Spin up subprocesses for tidying field HTML in-place.
    batches: List[List[ExtantFile]] = list(F.get_batches(F.rglob(root, &#34;*&#34;), BATCH_SIZE))
    for batch in tqdm(batches, ncols=TQDM_NUM_COLS, disable=silent):

        # Fail silently here, so as to not bother user with tidy warnings.
        command = [&#34;tidy&#34;, &#34;-q&#34;, &#34;-m&#34;, &#34;-i&#34;, &#34;-omit&#34;, &#34;-utf8&#34;, &#34;--tidy-mark&#34;, &#34;no&#34;]
        command += batch
        try:
            subprocess.run(command, check=False, capture_output=True)
        except Exception as err:
            return Err(err)
    return Ok()


@monadic
@beartype
def flatten_staging_repo(
    stage_kirepo: KiRepo, kirepo: KiRepo
) -&gt; Result[KiRepo, Exception]:
    &#34;&#34;&#34;
    Convert the staging repository into a format that is amenable to taking
    diffs across all files in all submodules.

    To do this, we first convert all submodules into ordinary subdirectories of
    the git repository. Then we replace the dot git directory of the staging
    repo with the .git directory of the repo in `.ki/no_submodules_tree/`,
    which, as its name suggests, is a copy of the main repository with all its
    submodules converted into directories.

    This is done in order to preserve the history of
    `.ki/no_submodules_tree/`. The staging repository can be thought of as
    the next commit to this repo.

    We return a reloaded version of the staging repository, re-read from disk.
    &#34;&#34;&#34;
    unsubmodule_repo(stage_kirepo.repo)

    # Shutil rmtree the stage repo .git directory.
    stage_git_dir: NoPath = F.rmtree(F.git_dir(stage_kirepo.repo))
    stage_root: ExtantDir = stage_kirepo.root
    del stage_kirepo

    # Copy the .git folder from `no_submodules_tree` into the stage repo.
    stage_git_dir = F.copytree(F.git_dir(kirepo.no_modules_repo), stage_git_dir)
    stage_root: ExtantDir = F.parent(stage_git_dir)

    # Reload stage kirepo.
    stage_kirepo: Res[KiRepo] = M.kirepo(stage_root)

    return stage_kirepo


@monadic
@beartype
def get_target(
    cwd: ExtantDir, col_file: ExtantFile, directory: str
) -&gt; Result[EmptyDir, Exception]:
    # Create default target directory.
    path = F.test(Path(directory) if directory != &#34;&#34; else cwd / col_file.stem)
    if isinstance(path, NoPath):
        path.mkdir(parents=True)
        return M.emptydir(path)
    if isinstance(path, EmptyDir):
        return Ok(path)
    return Err(TargetExistsError(path))


@click.group()
@click.version_option()
@beartype
def ki() -&gt; None:
    &#34;&#34;&#34;
    The universal CLI entry point for `ki`.

    Takes no arguments, only has three subcommands (clone, pull, push).
    &#34;&#34;&#34;
    return


@ki.command()
@click.argument(&#34;collection&#34;)
@click.argument(&#34;directory&#34;, required=False, default=&#34;&#34;)
def clone(collection: str, directory: str = &#34;&#34;) -&gt; Result[bool, Exception]:
    &#34;&#34;&#34;
    Clone an Anki collection into a directory.

    Parameters
    ----------
    collection : str
        The path to a `.anki2` collection file.
    directory : str, default=&#34;&#34;
        An optional path to a directory to clone the collection into.
        Note: we check that this directory does not yet exist.
    &#34;&#34;&#34;
    echo(&#34;Cloning.&#34;)
    col_file: Res[ExtantFile] = M.xfile(Path(collection))

    cwd: ExtantDir = F.cwd()
    targetdir: Res[EmptyDir] = get_target(cwd, col_file, directory)
    md5sum: Res[str] = _clone(col_file, targetdir, msg=&#34;Initial commit&#34;, silent=False)

    # Check that we are inside a ki repository, and get the associated collection.
    targetdir: Res[ExtantDir] = M.xdir(targetdir)
    kirepo: Res[KiRepo] = M.kirepo(targetdir)

    # Get reference to HEAD of current repo.
    head: Res[KiRepoRef] = M.head_kirepo_ref(kirepo)

    if targetdir.is_err() or head.is_err():
        echo(&#34;Failed: exiting.&#34;)

        # We get an error here only in the case where the `M.xdir()` call
        # failed on `targetdir`. We cannot assume that it doesn&#39;t exist,
        # because we may have returned the exception inside `fmkdempty()`,
        # which errors-out when the target already exists and is nonempty. This
        # means we definitely do not want to remove `targetdir` or its
        # contents in this case, because we would be deleting the user&#39;s data.
        if targetdir.is_err():
            return targetdir

        # Otherwise, we must have that either we created `targetdir` and it did
        # not exist prior, or it was an empty directory before. In either case,
        # we can probably remove it safely.
        # TODO: Consider removing only its contents instead.
        targetdir: ExtantDir = targetdir.unwrap()
        if targetdir.is_dir():
            shutil.rmtree(targetdir)
        return head

    head: KiRepoRef = head.unwrap()

    # Get staging repository in temp directory, and copy to `no_submodules_tree`.

    # Copy current kirepo into a temp directory (the STAGE), hard reset to HEAD.
    stage_kirepo: Res[KiRepo] = get_ephemeral_kirepo(STAGE_SUFFIX, head, md5sum)
    stage_kirepo = flatten_staging_repo(stage_kirepo, kirepo)
    if stage_kirepo.is_err():
        echo(&#34;Failed: exiting.&#34;)
        return stage_kirepo
    stage_kirepo: KiRepo = stage_kirepo.unwrap()

    stage_kirepo.repo.git.add(all=True)
    stage_kirepo.repo.index.commit(f&#34;Pull changes from ref {head.sha}&#34;)

    # Completely annihilate the `.ki/no_submodules_tree`
    # directory/repository, and replace it with `stage_kirepo`. This is a
    # sensible operation because earlier, we copied the `.git/` directory
    # from `.ki/no_submodules_tree` to the staging repo. So the history is
    # preserved.
    no_modules_root: NoPath = F.rmtree(F.working_dir(head.kirepo.no_modules_repo))
    F.copytree(stage_kirepo.root, no_modules_root)

    kirepo: Res[KiRepo] = M.kirepo(targetdir)
    if kirepo.is_err():
        echo(&#34;Failed: exiting.&#34;)
        return kirepo
    kirepo: KiRepo = kirepo.unwrap()

    # Dump HEAD ref of current repo in `.ki/last_push`.
    kirepo.last_push_file.write_text(head.sha)

    return Ok()


@monadic
@beartype
def _clone(
    col_file: ExtantFile, targetdir: EmptyDir, msg: str, silent: bool
) -&gt; Result[str, Exception]:
    &#34;&#34;&#34;
    Clone an Anki collection into a directory.

    The caller, realistically only `clone()`, expects that `targetdir` will
    be the root of a valid ki repository after this function is called, so we
    need to do our repo initialization with gitpython in here, as opposed to in
    `clone()`.

    Parameters
    ----------
    col_file : pathlib.Path
        The path to a `.anki2` collection file.
    targetdir : pathlib.Path
        A path to a directory to clone the collection into.
        Note: we check that this directory is empty.
    msg : str
        Message for initial commit.
    silent : bool
        Indicates whether we are calling `_clone()` from `pull()`.

    Returns
    -------
    git.Repo
        The cloned repository.
    &#34;&#34;&#34;
    echo(f&#34;Found .anki2 file at &#39;{col_file}&#39;&#34;, silent=silent)

    # Create .ki subdirectory.
    ki_dir: EmptyDir = F.mksubdir(targetdir, Path(KI))

    # Populate the .ki subdirectory with empty metadata files.
    leaves: Res[Leaves] = F.fmkleaves(
        ki_dir,
        files={CONFIG_FILE: CONFIG_FILE, LAST_PUSH_FILE: LAST_PUSH_FILE},
        dirs={BACKUPS_DIR: BACKUPS_DIR, NO_SM_DIR: NO_SM_DIR},
    )

    md5sum = F.md5(col_file)
    echo(f&#34;Computed md5sum: {md5sum}&#34;, silent)
    echo(f&#34;Cloning into &#39;{targetdir}&#39;...&#34;, silent=silent)

    # Add `.ki/` to gitignore.
    ignore_path = targetdir / GITIGNORE_FILE
    ignore_path.write_text(&#34;.ki/\n&#34;)

    # Write notes to disk. We do explicit error checking here because if we
    # don&#39;t the repository initialization will run even when there&#39;s a failure.
    # This would be very bad for speed, because gitpython calls have quite a
    # bit of overhead sometimes (although maybe not for `Repo.init()` calls,
    # since they aren&#39;t networked).
    wrote: OkErr = write_repository(col_file, targetdir, leaves, silent)
    if wrote.is_err():
        return wrote

    initialized: OkErr = init_repos(targetdir, leaves, msg)
    if initialized.is_err():
        return initialized

    # Store the md5sum of the anki collection file in the hashes file (we
    # always append, never overwrite).
    append_md5sum(ki_dir, col_file.name, md5sum, silent)

    return Ok(md5sum)


# TODO: Remove this function.
@monadic
@beartype
def init_repos(
    targetdir: ExtantDir, leaves: Leaves, msg: str
) -&gt; Result[bool, Exception]:
    &#34;&#34;&#34;
    Initialize both git repos and commit contents of the main one.
    &#34;&#34;&#34;
    repo = git.Repo.init(targetdir, initial_branch=BRANCH_NAME)
    repo.git.add(all=True)
    _ = repo.index.commit(msg)

    # Initialize the copy of the repository with submodules replaced with
    # subdirectories that lives in `.ki/no_submodules_tree/`.
    _ = git.Repo.init(leaves.dirs[NO_SM_DIR], initial_branch=BRANCH_NAME)

    return Ok()


@ki.command()
@beartype
def pull() -&gt; Result[bool, Exception]:
    &#34;&#34;&#34;
    Pull from a preconfigured remote Anki collection into an existing ki
    repository.
    &#34;&#34;&#34;

    # Check that we are inside a ki repository, and get the associated collection.
    cwd: ExtantDir = F.cwd()
    kirepo: Res[KiRepo] = M.kirepo(cwd)
    if kirepo.is_err():
        return kirepo
    kirepo: KiRepo = kirepo.unwrap()
    con: sqlite3.Connection = lock(kirepo)

    md5sum: str = F.md5(kirepo.col_file)
    hashes: List[str] = kirepo.hashes_file.read_text().split(&#34;\n&#34;)
    hashes = list(filter(lambda l: l != &#34;&#34;, hashes))
    logger.debug(f&#34;Hashes:\n{pp.pformat(hashes)}&#34;)
    if md5sum in hashes[-1]:
        echo(&#34;ki pull: up to date.&#34;)
        return Ok(unlock(con))

    echo(f&#34;Pulling from &#39;{kirepo.col_file}&#39;&#34;)
    echo(f&#34;Computed md5sum: {md5sum}&#34;)

    # Git clone `repo` at commit SHA of last successful `push()`.
    sha: str = kirepo.last_push_file.read_text()
    ref: Res[RepoRef] = M.repo_ref(kirepo.repo, sha)
    last_push_repo: Res[git.Repo] = get_ephemeral_repo(LOCAL_SUFFIX, ref, md5sum)

    # Ki clone collection into an ephemeral ki repository at `anki_remote_root`.
    msg = f&#34;Fetch changes from DB at &#39;{kirepo.col_file}&#39; with md5sum &#39;{md5sum}&#39;&#34;
    anki_remote_root: EmptyDir = F.mksubdir(F.mkdtemp(), REMOTE_SUFFIX / md5sum)

    # This should return the repository as well.
    cloned: Res[str] = _clone(kirepo.col_file, anki_remote_root, msg, silent=True)
    pulled: OkErr = pull_changes_from_remote_repo(
        kirepo, anki_remote_root, last_push_repo, md5sum, cloned
    )
    if pulled.is_err():
        return pulled
    return Ok(unlock(con))


# TODO: Remove this function.
@monadic
@beartype
def pull_theirs_from_remote(
    repo: git.Repo, root: ExtantDir, remote: git.Remote
) -&gt; Result[bool, Exception]:
    cwd: ExtantDir = F.chdir(root)
    echo(f&#34;Pulling into {root}&#34;)
    repo.git.config(&#34;pull.rebase&#34;, &#34;false&#34;)
    # TODO: This is not yet safe. Consider rewriting with gitpython.
    git_subprocess_pull(REMOTE_NAME, BRANCH_NAME)
    repo.delete_remote(remote)
    F.chdir(cwd)
    return Ok()


@monadic
@beartype
def pull_changes_from_remote_repo(
    kirepo: KiRepo,
    anki_remote_root: ExtantDir,
    last_push_repo: git.Repo,
    md5sum: str,
    _cloned: str,
) -&gt; Result[bool, Exception]:
    &#34;&#34;&#34;
    Load the git repository at `anki_remote_root`, force pull (preferring
    &#39;theirs&#39;, i.e. the new stuff from the sqlite3 database) changes from that
    repository (which is cloned straight from the collection, which in general
    may have new changes) into `last_push_repo`, and then pull
    `last_push_repo` into the main repository.

    We pull in this sequence in order to avoid merge conflicts. Since we first
    pull into a snapshot of the repository as it looked when we last pushed to
    the database, we know that there cannot be any merge conflicts, because to
    git, it just looks like we haven&#39;t made any changes since then. Then we
    pull the result of that merge into our actual repository. So there could
    still be merge conflicts at that point, but they will only be &#39;genuine&#39;
    merge conflicts in some sense, because as a result of using this snapshot
    strategy, we give the anki collection the appearance of being a persistent
    remote git repo. If we didn&#39;t do this, the fact that we did a fresh clone
    of the database every time would mean that everything would look like a
    merge conflict, because there is no shared history.
    &#34;&#34;&#34;
    remote_repo: Res[git.Repo] = M.repo(anki_remote_root)
    if remote_repo.is_err():
        return remote_repo
    remote_repo: git.Repo = remote_repo.unwrap()

    # Create git remote pointing to anki remote repo.
    anki_remote = last_push_repo.create_remote(REMOTE_NAME, remote_repo.git_dir)

    # Pull anki remote repo into `last_push_repo`.
    last_push_root: Res[ExtantDir] = F.working_dir(last_push_repo)
    pulled: OkErr = pull_theirs_from_remote(last_push_repo, last_push_root, anki_remote)
    if pulled.is_err():
        return pulled

    # Create remote pointing to `last_push` repo and pull into `repo`.
    last_push_remote = kirepo.repo.create_remote(REMOTE_NAME, last_push_repo.git_dir)
    kirepo.repo.git.config(&#34;pull.rebase&#34;, &#34;false&#34;)
    p = subprocess.run(
        [&#34;git&#34;, &#34;pull&#34;, &#34;-v&#34;, REMOTE_NAME, BRANCH_NAME],
        check=False,
        capture_output=True,
    )
    click.secho(f&#34;{p.stdout.decode()}&#34;, bold=True)
    click.secho(f&#34;{p.stderr.decode()}&#34;, bold=True)
    kirepo.repo.delete_remote(last_push_remote)

    # Append to hashes file.
    append_md5sum(kirepo.ki_dir, kirepo.col_file.name, md5sum, silent=True)

    # Check that md5sum hasn&#39;t changed.
    if F.md5(kirepo.col_file) != md5sum:
        return Err(CollectionChecksumError(kirepo.col_file))
    return Ok()


# PUSH


@ki.command()
@beartype
def push() -&gt; Result[bool, Exception]:
    &#34;&#34;&#34;Push a ki repository into a .anki2 file.&#34;&#34;&#34;
    pp.install_extras(exclude=[&#34;ipython&#34;, &#34;django&#34;, &#34;ipython_repr_pretty&#34;])

    # Check that we are inside a ki repository, and get the associated collection.
    cwd: ExtantDir = F.cwd()
    kirepo: Res[KiRepo] = M.kirepo(cwd)
    if kirepo.is_err():
        return kirepo
    kirepo: KiRepo = kirepo.unwrap()
    con: sqlite3.Connection = lock(kirepo)

    md5sum: str = F.md5(kirepo.col_file)
    hashes: List[str] = kirepo.hashes_file.read_text().split(&#34;\n&#34;)
    hashes = list(filter(lambda l: l != &#34;&#34;, hashes))
    logger.debug(f&#34;Hashes:\n{pp.pformat(hashes)}&#34;)
    if md5sum not in hashes[-1]:
        return Err(UpdatesRejectedError(kirepo.col_file))

    # Get reference to HEAD of current repo.
    head: Res[KiRepoRef] = M.head_kirepo_ref(kirepo)
    if head.is_err():
        return head
    head: KiRepoRef = head.unwrap()

    # Copy current kirepo into a temp directory (the STAGE), hard reset to HEAD.
    stage_kirepo: OkErr = get_ephemeral_kirepo(STAGE_SUFFIX, head, md5sum)
    stage_kirepo = flatten_staging_repo(stage_kirepo, kirepo)
    if stage_kirepo.is_err():
        return stage_kirepo
    stage_kirepo: KiRepo = stage_kirepo.unwrap()

    # This statement cannot be any farther down because we must get a reference
    # to HEAD *before* we commit, and then after the following line, the
    # reference we got will be HEAD~1, hence the variable name.
    head_1: Res[RepoRef] = M.head_repo_ref(stage_kirepo.repo)
    if head_1.is_err():
        return head_1
    head_1: RepoRef = head_1.unwrap()

    stage_kirepo.repo.git.add(all=True)
    stage_kirepo.repo.index.commit(f&#34;Pull changes from ref {head.sha}&#34;)

    # Get filter function.
    filter_fn = functools.partial(filter_note_path, patterns=IGNORE, root=kirepo.root)

    head_kirepo: Res[KiRepo] = get_ephemeral_kirepo(LOCAL_SUFFIX, head, md5sum)

    # Read grammar.
    # TODO:! Should we assume this always exists? A nice error message should
    # be printed on initialization if the grammar file is missing. No
    # computation should be done, and none of the click commands should work.
    grammar_path = Path(__file__).resolve().parent / &#34;grammar.lark&#34;
    grammar = grammar_path.read_text(encoding=&#34;UTF-8&#34;)

    # Instantiate parser.
    parser = Lark(grammar, start=&#34;file&#34;, parser=&#34;lalr&#34;)
    transformer = NoteTransformer()

    # Get deltas.
    a_repo: Res[git.Repo] = get_ephemeral_repo(DELETED_SUFFIX, head_1, md5sum)
    b_repo: git.Repo = head_1.repo
    deltas: OkErr = diff_repos(a_repo, b_repo, head_1, filter_fn, parser, transformer)

    # Map model names to models.
    models: Res[Dict[str, Notetype]] = get_models_recursively(head_kirepo)

    return push_deltas(
        deltas, models, kirepo, md5sum, parser, transformer, stage_kirepo, con
    )


@monadic
@beartype
def push_deltas(
    deltas: List[Delta],
    models: Dict[str, Notetype],
    kirepo: KiRepo,
    md5sum: str,
    parser: Lark,
    transformer: NoteTransformer,
    stage_kirepo: KiRepo,
    con: sqlite3.Connection,
) -&gt; Result[bool, Exception]:

    # If there are no changes, quit.
    if len(set(deltas)) == 0:
        echo(&#34;ki push: up to date.&#34;)
        return Ok()

    echo(f&#34;Pushing to &#39;{kirepo.col_file}&#39;&#34;)
    echo(f&#34;Computed md5sum: {md5sum}&#34;)
    echo(f&#34;Verified md5sum matches latest hash in &#39;{kirepo.hashes_file}&#39;&#34;)

    # Copy collection to a temp directory.
    temp_col_dir: ExtantDir = F.mkdtemp()
    new_col_file = temp_col_dir / kirepo.col_file.name
    col_name: str = kirepo.col_file.name
    new_col_file: ExtantFile = F.copyfile(kirepo.col_file, temp_col_dir, col_name)

    head: Res[RepoRef] = M.head_repo_ref(kirepo.repo)
    if head.is_err():
        echo(&#34;Failed: no commits in repository. Couldn&#39;t find HEAD ref.&#34;)
        return Ok()
    head = head.unwrap()
    echo(f&#34;Generating local .anki2 file from latest commit: {head.sha}&#34;)
    echo(f&#34;Writing changes to &#39;{new_col_file}&#39;...&#34;)

    cwd: ExtantDir = F.cwd()
    col = Collection(new_col_file)
    F.chdir(cwd)
    modified = True

    # Add all new models.
    for model in models.values():

        # TODO: Consider waiting to parse `models` until after the
        # `add_dict()` call.
        if col.models.id_for_name(model.name) is not None:

            nt_copy: NotetypeDict = copy.deepcopy(model.dict)
            nt_copy[&#34;id&#34;] = 0
            changes: OpChangesWithId = col.models.add_dict(nt_copy)
            nt: NotetypeDict = col.models.get(changes.id)
            model: OkErr = parse_notetype_dict(nt)
            if model.is_err():
                return model

    # Gather logging statements to display.
    log: List[str] = []

    # Stash both unstaged and staged files (including untracked).
    kirepo.repo.git.stash(include_untracked=True, keep_index=True)
    kirepo.repo.git.reset(&#34;HEAD&#34;, hard=True)

    is_delete = lambda d: d.status == GitChangeType.DELETED
    deletes: List[Delta] = list(filter(is_delete, deltas))
    logger.debug(f&#34;Deleting {len(deletes)} notes.&#34;)

    for delta in tqdm(deltas, ncols=TQDM_NUM_COLS):

        # Parse the file at `delta.path` into a `FlatNote`, and
        # add/edit/delete in collection.
        flatnote = parse_markdown_note(parser, transformer, delta.path)
        logger.debug(f&#34;Resolving delta:\n{pp.pformat(delta)}\n{pp.pformat(flatnote)}&#34;)

        if is_delete(delta):
            logger.debug(f&#34;Deleting note {flatnote.nid}&#34;)
            col.remove_notes([flatnote.nid])
            continue

        # If a note with this nid exists in DB, update it.
        # TODO: If relevant prefix of sort field has changed, we regenerate
        # the file. Recall that the sort field is used to determine the
        # filename. If the content of the sort field has changed, then we
        # may need to update the filename.
        colnote: OkErr = push_flatnote_to_anki(col, flatnote)
        regenerated: OkErr = regenerate_note_file(colnote, kirepo.root, delta.relpath)
        if regenerated.is_err():
            regen_err: Exception = regenerated.unwrap_err()
            if isinstance(regen_err, Warning):
                continue
            return regenerated
        log += regenerated.unwrap()

    # Commit nid reassignments.
    logger.warning(f&#34;Reassigned {len(log)} nids.&#34;)
    if len(log) &gt; 0:
        msg = &#34;Generated new nid(s).\n\n&#34; + &#34;\n&#34;.join(log)

        # Commit in all submodules (doesn&#39;t support recursing yet).
        for sm in kirepo.repo.submodules:

            # TODO: Remove submodule update calls, and use the gitpython
            # API to check if the submodules exist instead. The update
            # calls make a remote fetch which takes an extremely long time,
            # and the user should have run `git submodule update`
            # themselves anyway.
            subrepo: git.Repo = sm.update().module()
            subrepo.git.add(all=True)
            subrepo.index.commit(msg)

        # Commit in main repository.
        kirepo.repo.git.add(all=True)
        _ = kirepo.repo.index.commit(msg)

    if modified:
        echo(&#34;Database was modified.&#34;)
        col.close()
    elif col.db:
        col.close(False)

    # Backup collection file and overwrite collection.
    backup(kirepo)
    new_col_file = F.copyfile(new_col_file, F.parent(kirepo.col_file), col_name)
    echo(f&#34;Overwrote &#39;{kirepo.col_file}&#39;&#34;)

    # Append to hashes file.
    new_md5sum = F.md5(new_col_file)
    append_md5sum(kirepo.ki_dir, new_col_file.name, new_md5sum, silent=False)

    # Completely annihilate the `.ki/no_submodules_tree`
    # directory/repository, and replace it with `stage_kirepo`. This is a
    # sensible operation because earlier, we copied the `.git/` directory
    # from `.ki/no_submodules_tree` to the staging repo. So the history is
    # preserved.
    no_modules_root: NoPath = F.rmtree(F.working_dir(kirepo.no_modules_repo))
    F.copytree(stage_kirepo.root, no_modules_root)

    # Dump HEAD ref of current repo in `.ki/last_push`.
    kirepo.last_push_file.write_text(head.sha)

    # Unlock Anki SQLite DB.
    unlock(con)

    return Ok()


@monadic
@beartype
def regenerate_note_file(
    colnote: ColNote, root: ExtantDir, relpath: Path
) -&gt; Result[List[str], Exception]:
    &#34;&#34;&#34;
    Construct the contents of a note corresponding to the arguments `colnote`,
    which itself was created from `flatnote`, and then write it to disk.

    Returns a list of lines to add to the commit message (either an empty list,
    or a list containing a single line).

    This function is intended to be used when we are adding *completely* new
    notes, in which case the caller generates a new note with a newly generated
    nid, which can be accessed at `colnote.n.id`. In general, this is the
    branch taken whenever Anki fails to recognize the nid given in the note
    file, which can be accessed via `colnote.old_nid`. Thus, we only regenerate
    if `colnote.n.id` and `colnote.old_nid` to differ, since the former has the
    newly assigned nid for this note, yielded by the Anki runtime, and the
    latter has whatever was written in the file.
    &#34;&#34;&#34;
    # If this is not a new note, then we didn&#39;t reassign its nid, and we don&#39;t
    # need to regenerate the file. So we don&#39;t add a line to the commit
    # message.
    if not colnote.new:
        return Ok([])

    # Get paths to note in local repo, as distinct from staging repo.
    repo_note_path: Path = root / relpath

    # If this is not an entirely new file, remove it.
    if repo_note_path.is_file():
        repo_note_path.unlink()

    parent: ExtantDir = F.force_mkdir(repo_note_path.parent)
    new_note_path: ExtantFile = get_note_path(colnote.sortf_text, parent)
    new_note_path.write_text(get_colnote_repr(colnote), encoding=&#34;UTF-8&#34;)

    # TODO: Figure out if this still works if we use pathlib instead.
    new_note_relpath = os.path.relpath(new_note_path, root)

    msg = f&#34;Reassigned nid: &#39;{colnote.old_nid}&#39; -&gt; &#39;{colnote.n.id}&#39; in &#39;{new_note_relpath}&#39;&#34;
    return Ok([msg])</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="ki.functional" href="functional.html">ki.functional</a></code></dt>
<dd>
<div class="desc"><p>Type-safe, non Anki-specific functions.</p></div>
</dd>
<dt><code class="name"><a title="ki.maybes" href="maybes.html">ki.maybes</a></code></dt>
<dd>
<div class="desc"><p>Monadic factory functions for safely handling errors in type construction.</p></div>
</dd>
<dt><code class="name"><a title="ki.monadic" href="monadic.html">ki.monadic</a></code></dt>
<dd>
<div class="desc"><p>A function decorator to lift functions up to the category <code>result.Result</code>.</p></div>
</dd>
<dt><code class="name"><a title="ki.transformer" href="transformer.html">ki.transformer</a></code></dt>
<dd>
<div class="desc"><p>A Lark transformer for the ki note grammar.</p></div>
</dd>
<dt><code class="name"><a title="ki.types" href="types.html">ki.types</a></code></dt>
<dd>
<div class="desc"><p>Types for ki.</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ki.append_md5sum"><code class="name flex">
<span>def <span class="ident">append_md5sum</span></span>(<span>ki_dir: <a title="ki.types.ExtantDir" href="types.html#ki.types.ExtantDir">ExtantDir</a>, tag: str, md5sum: str, silent: bool = False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Append an md5sum hash to the hashes file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def append_md5sum(
    ki_dir: ExtantDir, tag: str, md5sum: str, silent: bool = False
) -&gt; None:
    &#34;&#34;&#34;Append an md5sum hash to the hashes file.&#34;&#34;&#34;
    hashes_file = ki_dir / HASHES_FILE
    with open(hashes_file, &#34;a+&#34;, encoding=&#34;UTF-8&#34;) as hashes_f:
        hashes_f.write(f&#34;{md5sum}  {tag}\n&#34;)
    echo(f&#34;Wrote md5sum to &#39;{hashes_file}&#39;&#34;, silent)</code></pre>
</details>
</dd>
<dt id="ki.backup"><code class="name flex">
<span>def <span class="ident">backup</span></span>(<span>kirepo: <a title="ki.types.KiRepo" href="types.html#ki.types.KiRepo">KiRepo</a>) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Backup collection to <code>.ki/backups</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def backup(kirepo: KiRepo) -&gt; None:
    &#34;&#34;&#34;Backup collection to `.ki/backups`.&#34;&#34;&#34;
    md5sum = F.md5(kirepo.col_file)
    name = f&#34;{md5sum}.anki2&#34;
    backup_file = F.test(kirepo.backups_dir / name)

    # We assume here that no one would ever make e.g. a directory called
    # `name`, since `name` contains the md5sum of the collection file, and
    # thus that is extraordinarily improbable. So the only thing we have to
    # check for is that we haven&#39;t already written a backup file to this
    # location.
    if isinstance(backup_file, ExtantFile):
        echo(&#34;Backup already exists.&#34;)
        return

    echo(f&#34;Writing backup of .anki2 file to &#39;{backup_file}&#39;&#34;)
    F.copyfile(kirepo.col_file, kirepo.backups_dir, name)</code></pre>
</details>
</dd>
<dt id="ki.create_deck_dir"><code class="name flex">
<span>def <span class="ident">create_deck_dir</span></span>(<span>deck_name: str, targetdir: <a title="ki.types.ExtantDir" href="types.html#ki.types.ExtantDir">ExtantDir</a>) ‑> <a title="ki.types.ExtantDir" href="types.html#ki.types.ExtantDir">ExtantDir</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct path to deck directory and create it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def create_deck_dir(deck_name: str, targetdir: ExtantDir) -&gt; ExtantDir:
    &#34;&#34;&#34;Construct path to deck directory and create it.&#34;&#34;&#34;
    # Strip leading periods so we don&#39;t get hidden folders.
    components = deck_name.split(&#34;::&#34;)
    components = [re.sub(r&#34;^\.&#34;, r&#34;&#34;, comp) for comp in components]
    deck_path = Path(targetdir, *components)
    return F.force_mkdir(deck_path)</code></pre>
</details>
</dd>
<dt id="ki.diff_repos"><code class="name flex">
<span>def <span class="ident">diff_repos</span></span>(<span>a_repo: git.repo.base.Repo, b_repo: git.repo.base.Repo, ref: <a title="ki.types.RepoRef" href="types.html#ki.types.RepoRef">RepoRef</a>, filter_fn: collections.abc.Callable[[pathlib.Path], bool], parser: lark.lark.Lark, transformer: <a title="ki.transformer.NoteTransformer" href="transformer.html#ki.transformer.NoteTransformer">NoteTransformer</a>) ‑> Union[result.result.Ok[list[<a title="ki.types.Delta" href="types.html#ki.types.Delta">Delta</a>]], result.result.Err[Exception]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@monadic
@beartype
def diff_repos(
    a_repo: git.Repo,
    b_repo: git.Repo,
    ref: RepoRef,
    filter_fn: Callable[[Path], bool],
    parser: Lark,
    transformer: NoteTransformer,
) -&gt; Result[List[Delta], Exception]:
    # Use a `DiffIndex` to get the changed files.
    deltas = []
    a_dir = Path(a_repo.working_dir)
    b_dir = Path(b_repo.working_dir)
    logger.debug(f&#34;Diffing {ref.sha} against {b_repo.head.commit.hexsha}&#34;)
    diff_index = b_repo.commit(ref.sha).diff(b_repo.head.commit)
    for change_type in GitChangeType:
        for diff in diff_index.iter_change_type(change_type.value):

            if not filter_fn(a_dir / diff.a_path) or not filter_fn(a_dir / diff.b_path):
                logger.warning(f&#34;Ignoring:\n{diff.a_path}\n{diff.b_path}&#34;)
                continue

            a_path = F.test(a_dir / diff.a_path)
            b_path = F.test(b_dir / diff.b_path)

            a_relpath = Path(diff.a_path)
            b_relpath = Path(diff.b_path)

            if change_type == GitChangeType.DELETED:
                if not isinstance(a_path, ExtantFile):
                    logger.warning(f&#34;Deleted file not found in source commit: {a_path}&#34;)
                    continue

                deltas.append(Delta(change_type, a_path, a_relpath))
                continue

            if not isinstance(b_path, ExtantFile):
                logger.warning(f&#34;Diff target not found: {b_path}&#34;)
                continue

            if change_type == GitChangeType.RENAMED:
                a_flatnote: FlatNote = parse_markdown_note(parser, transformer, a_path)
                b_flatnote: FlatNote = parse_markdown_note(parser, transformer, b_path)
                if a_flatnote.nid != b_flatnote.nid:
                    logger.debug(f&#34;Adding delta: {change_type} {a_path} {b_path}&#34;)
                    deltas.append(Delta(GitChangeType.DELETED, a_path, a_relpath))
                    deltas.append(Delta(GitChangeType.ADDED, b_path, b_relpath))
                    continue

            logger.debug(f&#34;Adding delta: {change_type} {b_path}&#34;)
            deltas.append(Delta(change_type, b_path, b_relpath))

    return Ok(deltas)</code></pre>
</details>
</dd>
<dt id="ki.display_fields_health_warning"><code class="name flex">
<span>def <span class="ident">display_fields_health_warning</span></span>(<span>note: anki.notes.Note) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Display warnings when Anki's fields health check fails.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def display_fields_health_warning(note: anki.notes.Note) -&gt; int:
    &#34;&#34;&#34;Display warnings when Anki&#39;s fields health check fails.&#34;&#34;&#34;
    health = note.fields_check()
    if health == 1:
        logger.warning(f&#34;Found empty note:\n {note}&#34;)
        logger.warning(f&#34;Fields health check code: {health}&#34;)
    elif health == 2:
        logger.warning(f&#34;\nFound duplicate note when adding new note w/ nid {note.id}.&#34;)
        logger.warning(f&#34;Notetype/fields of note {note.id} match existing note.&#34;)
        logger.warning(&#34;Note was not added to collection!&#34;)
        logger.warning(f&#34;First field: {note.fields[0]}&#34;)
        logger.warning(f&#34;Fields health check code: {health}&#34;)
    elif health != 0:
        logger.error(f&#34;Failed to process note &#39;{note.id}&#39;.&#34;)
        logger.error(f&#34;Note failed fields check with unknown error code: {health}&#34;)
    return health</code></pre>
</details>
</dd>
<dt id="ki.echo"><code class="name flex">
<span>def <span class="ident">echo</span></span>(<span>string: str, silent: bool = False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Call <code>click.secho()</code> with formatting.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def echo(string: str, silent: bool = False) -&gt; None:
    &#34;&#34;&#34;Call `click.secho()` with formatting.&#34;&#34;&#34;
    if not silent:
        click.secho(string, bold=True)
        # logger.info(string)</code></pre>
</details>
</dd>
<dt id="ki.filter_note_path"><code class="name flex">
<span>def <span class="ident">filter_note_path</span></span>(<span>path: pathlib.Path, patterns: list[str], root: <a title="ki.types.ExtantDir" href="types.html#ki.types.ExtantDir">ExtantDir</a>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Lambda to be used as first argument to filter(). Filters out paths-to-ignore.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def filter_note_path(path: Path, patterns: List[str], root: ExtantDir) -&gt; bool:
    &#34;&#34;&#34;Lambda to be used as first argument to filter(). Filters out paths-to-ignore.&#34;&#34;&#34;
    for p in patterns:
        if p == path.name:
            logger.warning(f&#34;Ignoring {path} matching pattern {p}&#34;)
            return False

    # Ignore files that match a pattern in `patterns` (&#39;*&#39; not supported).
    for ignore_path in [root / p for p in patterns]:
        parents = [path.resolve()] + [p.resolve() for p in path.parents]
        if ignore_path.resolve() in parents:
            logger.warning(f&#34;Ignoring {path} matching pattern {ignore_path}&#34;)
            return False

    # If `path` is an extant file (not a directory) and NOT a note, ignore it.
    if path.exists() and path.resolve().is_file():
        file = ExtantFile(path.resolve())
        if not is_anki_note(file):
            logger.warning(f&#34;Not Anki note {file}&#34;)
            return False

    return True</code></pre>
</details>
</dd>
<dt id="ki.flatten_staging_repo"><code class="name flex">
<span>def <span class="ident">flatten_staging_repo</span></span>(<span>stage_kirepo: <a title="ki.types.KiRepo" href="types.html#ki.types.KiRepo">KiRepo</a>, kirepo: <a title="ki.types.KiRepo" href="types.html#ki.types.KiRepo">KiRepo</a>) ‑> Union[result.result.Ok[<a title="ki.types.KiRepo" href="types.html#ki.types.KiRepo">KiRepo</a>], result.result.Err[Exception]]</span>
</code></dt>
<dd>
<div class="desc"><p>Convert the staging repository into a format that is amenable to taking
diffs across all files in all submodules.</p>
<p>To do this, we first convert all submodules into ordinary subdirectories of
the git repository. Then we replace the dot git directory of the staging
repo with the .git directory of the repo in <code>.ki/no_submodules_tree/</code>,
which, as its name suggests, is a copy of the main repository with all its
submodules converted into directories.</p>
<p>This is done in order to preserve the history of
<code>.ki/no_submodules_tree/</code>. The staging repository can be thought of as
the next commit to this repo.</p>
<p>We return a reloaded version of the staging repository, re-read from disk.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@monadic
@beartype
def flatten_staging_repo(
    stage_kirepo: KiRepo, kirepo: KiRepo
) -&gt; Result[KiRepo, Exception]:
    &#34;&#34;&#34;
    Convert the staging repository into a format that is amenable to taking
    diffs across all files in all submodules.

    To do this, we first convert all submodules into ordinary subdirectories of
    the git repository. Then we replace the dot git directory of the staging
    repo with the .git directory of the repo in `.ki/no_submodules_tree/`,
    which, as its name suggests, is a copy of the main repository with all its
    submodules converted into directories.

    This is done in order to preserve the history of
    `.ki/no_submodules_tree/`. The staging repository can be thought of as
    the next commit to this repo.

    We return a reloaded version of the staging repository, re-read from disk.
    &#34;&#34;&#34;
    unsubmodule_repo(stage_kirepo.repo)

    # Shutil rmtree the stage repo .git directory.
    stage_git_dir: NoPath = F.rmtree(F.git_dir(stage_kirepo.repo))
    stage_root: ExtantDir = stage_kirepo.root
    del stage_kirepo

    # Copy the .git folder from `no_submodules_tree` into the stage repo.
    stage_git_dir = F.copytree(F.git_dir(kirepo.no_modules_repo), stage_git_dir)
    stage_root: ExtantDir = F.parent(stage_git_dir)

    # Reload stage kirepo.
    stage_kirepo: Res[KiRepo] = M.kirepo(stage_root)

    return stage_kirepo</code></pre>
</details>
</dd>
<dt id="ki.get_colnote"><code class="name flex">
<span>def <span class="ident">get_colnote</span></span>(<span>col: anki.collection.Collection, nid: int) ‑> Union[result.result.Ok[<a title="ki.types.ColNote" href="types.html#ki.types.ColNote">ColNote</a>], result.result.Err[Exception]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def get_colnote(col: Collection, nid: int) -&gt; Result[ColNote, Exception]:
    try:
        note = col.get_note(nid)
    except anki.errors.NotFoundError:
        return Err(MissingNoteIdError(nid))
    notetype: OkErr = parse_notetype_dict(note.note_type())
    if notetype.is_err():
        return notetype
    notetype: Notetype = notetype.unwrap()

    # Get sort field content.
    try:
        sortf_text: str = note[notetype.sortf.name]
    except KeyError as err:
        return Err(err)

    # TODO: Remove implicit assumption that all cards are in the same deck, and
    # work with cards instead of notes.
    deck = col.decks.name(note.cards()[0].did)
    colnote = ColNote(
        n=note,
        new=False,
        deck=deck,
        title=&#34;&#34;,
        old_nid=note.id,
        markdown=False,
        notetype=notetype,
        sortf_text=sortf_text,
    )
    return Ok(colnote)</code></pre>
</details>
</dd>
<dt id="ki.get_colnote_repr"><code class="name flex">
<span>def <span class="ident">get_colnote_repr</span></span>(<span>colnote: <a title="ki.types.ColNote" href="types.html#ki.types.ColNote">ColNote</a>) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def get_colnote_repr(colnote: ColNote) -&gt; str:
    lines = get_header_lines(colnote)
    for field_name, field_text in colnote.n.items():
        lines.append(&#34;### &#34; + field_name)
        lines.append(html_to_screen(field_text))
        lines.append(&#34;&#34;)

    return &#34;\n&#34;.join(lines)</code></pre>
</details>
</dd>
<dt id="ki.get_ephemeral_kirepo"><code class="name flex">
<span>def <span class="ident">get_ephemeral_kirepo</span></span>(<span>suffix: pathlib.Path, kirepo_ref: <a title="ki.types.KiRepoRef" href="types.html#ki.types.KiRepoRef">KiRepoRef</a>, md5sum: str) ‑> Union[result.result.Ok[<a title="ki.types.KiRepo" href="types.html#ki.types.KiRepo">KiRepo</a>], result.result.Err[Exception]]</span>
</code></dt>
<dd>
<div class="desc"><p>Given a KiRepoRef, i.e. a pair of the form (kirepo, SHA), we clone
<code>kirepo.repo</code> into a temp directory and hard reset to the given commit
hash.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>suffix</code></strong> :&ensp;<code>pathlib.Path</code></dt>
<dd>/tmp/&hellip;/ path suffix, e.g. <code>ki/local/</code>.</dd>
<dt><strong><code>kirepo_ref</code></strong> :&ensp;<code>KiRepoRef</code></dt>
<dd>The ki repository to clone, and a commit for it.</dd>
<dt><strong><code>md5sum</code></strong> :&ensp;<code>str</code></dt>
<dd>The md5sum of the associated anki collection.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>KiRepo</code></dt>
<dd>The cloned repository.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@monadic
@beartype
def get_ephemeral_kirepo(
    suffix: Path, kirepo_ref: KiRepoRef, md5sum: str
) -&gt; Result[KiRepo, Exception]:
    &#34;&#34;&#34;
    Given a KiRepoRef, i.e. a pair of the form (kirepo, SHA), we clone
    `kirepo.repo` into a temp directory and hard reset to the given commit
    hash.

    Parameters
    ----------
    suffix : pathlib.Path
        /tmp/.../ path suffix, e.g. `ki/local/`.
    kirepo_ref : KiRepoRef
        The ki repository to clone, and a commit for it.
    md5sum : str
        The md5sum of the associated anki collection.

    Returns
    -------
    KiRepo
        The cloned repository.
    &#34;&#34;&#34;
    ref: Res[RepoRef] = M.repo_ref(kirepo_ref.kirepo.repo, kirepo_ref.sha)
    ephem: Res[git.Repo] = get_ephemeral_repo(suffix, ref, md5sum)
    if ephem.is_err():
        return ephem
    ephem: git.Repo = ephem.unwrap()
    ephem_ki_dir: OkErr = M.nopath(Path(ephem.working_dir) / KI)
    if ephem_ki_dir.is_err():
        return ephem_ki_dir
    ephem_ki_dir: NoPath = ephem_ki_dir.unwrap()
    F.copytree(kirepo_ref.kirepo.ki_dir, ephem_ki_dir)
    kirepo: Res[KiRepo] = M.kirepo(F.working_dir(ephem))

    return kirepo</code></pre>
</details>
</dd>
<dt id="ki.get_ephemeral_repo"><code class="name flex">
<span>def <span class="ident">get_ephemeral_repo</span></span>(<span>suffix: pathlib.Path, repo_ref: <a title="ki.types.RepoRef" href="types.html#ki.types.RepoRef">RepoRef</a>, md5sum: str) ‑> Union[result.result.Ok[git.repo.base.Repo], result.result.Err[Exception]]</span>
</code></dt>
<dd>
<div class="desc"><p>Get a temporary copy of a git repository in /tmp/<suffix>/.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@monadic
@beartype
def get_ephemeral_repo(
    suffix: Path, repo_ref: RepoRef, md5sum: str
) -&gt; Result[git.Repo, Exception]:
    &#34;&#34;&#34;Get a temporary copy of a git repository in /tmp/&lt;suffix&gt;/.&#34;&#34;&#34;
    tempdir: EmptyDir = F.mkdtemp()
    root: EmptyDir = F.mksubdir(tempdir, suffix)

    # Git clone `repo` at latest commit in `/tmp/.../&lt;suffix&gt;/&lt;md5sum&gt;`.
    repo: git.Repo = repo_ref.repo
    branch = repo.active_branch
    target: Path = root / md5sum

    # UNSAFE: But only called here, and it should be guaranteed to work because
    # `repo` is actually a git repository, presumably there is always an
    # active branch, and `target` does not exist.
    ephem = git.Repo.clone_from(repo.working_dir, target, branch=branch, recursive=True)

    # Do a reset --hard to the given SHA.
    ephem.git.reset(repo_ref.sha, hard=True)

    return Ok(ephem)</code></pre>
</details>
</dd>
<dt id="ki.get_field_note_id"><code class="name flex">
<span>def <span class="ident">get_field_note_id</span></span>(<span>nid: int, fieldname: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>A str ID that uniquely identifies field-note pairs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def get_field_note_id(nid: int, fieldname: str) -&gt; str:
    &#34;&#34;&#34;A str ID that uniquely identifies field-note pairs.&#34;&#34;&#34;
    return f&#34;{nid}{F.slugify(fieldname, allow_unicode=True)}&#34;</code></pre>
</details>
</dd>
<dt id="ki.get_header_lines"><code class="name flex">
<span>def <span class="ident">get_header_lines</span></span>(<span>colnote) ‑> list[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Get header of markdown representation of note.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def get_header_lines(colnote) -&gt; List[str]:
    &#34;&#34;&#34;Get header of markdown representation of note.&#34;&#34;&#34;
    lines = [
        &#34;## Note&#34;,
        f&#34;nid: {colnote.n.id}&#34;,
        f&#34;model: {colnote.notetype.name}&#34;,
    ]

    lines += [f&#34;deck: {colnote.deck}&#34;]
    lines += [f&#34;tags: {&#39;, &#39;.join(colnote.n.tags)}&#34;]

    if not any(GENERATED_HTML_SENTINEL in field for field in colnote.n.values()):
        lines += [&#34;markdown: false&#34;]

    lines += [&#34;&#34;]
    return lines</code></pre>
</details>
</dd>
<dt id="ki.get_models_recursively"><code class="name flex">
<span>def <span class="ident">get_models_recursively</span></span>(<span>kirepo: <a title="ki.types.KiRepo" href="types.html#ki.types.KiRepo">KiRepo</a>) ‑> Union[result.result.Ok[dict[str, <a title="ki.types.Notetype" href="types.html#ki.types.Notetype">Notetype</a>]], result.result.Err[Exception]]</span>
</code></dt>
<dd>
<div class="desc"><p>Find and merge all <code>models.json</code> files recursively.</p>
<p>Should we check for duplicates?</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result[Dict[int, Notetype], Exception]</code></dt>
<dd>A result.Result that returns a dictionary sending model names to
Notetypes.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@monadic
@beartype
def get_models_recursively(kirepo: KiRepo) -&gt; Result[Dict[str, Notetype], Exception]:
    &#34;&#34;&#34;
    Find and merge all `models.json` files recursively.

    Should we check for duplicates?

    Returns
    -------
    Result[Dict[int, Notetype], Exception]
        A result.Result that returns a dictionary sending model names to
        Notetypes.
    &#34;&#34;&#34;
    all_models: Dict[str, Notetype] = {}

    # Load notetypes from json files.
    for models_file in F.rglob(kirepo.root, MODELS_FILE):
        with open(models_file, &#34;r&#34;, encoding=&#34;UTF-8&#34;) as models_f:
            models: Dict[str, Notetype] = {}
            new_nts: Dict[int, Dict[str, Any]] = json.load(models_f)
            for _, nt in new_nts.items():
                parsed = parse_notetype_dict(nt)
                if parsed.is_err():
                    return parsed
                notetype: Notetype = parsed.ok()
                models[notetype.name] = notetype

        # Add mappings to dictionary.
        all_models.update(models)

    return Ok(all_models)</code></pre>
</details>
</dd>
<dt id="ki.get_note_path"><code class="name flex">
<span>def <span class="ident">get_note_path</span></span>(<span>sort_field_text: str, deck_dir: <a title="ki.types.ExtantDir" href="types.html#ki.types.ExtantDir">ExtantDir</a>) ‑> <a title="ki.types.ExtantFile" href="types.html#ki.types.ExtantFile">ExtantFile</a></span>
</code></dt>
<dd>
<div class="desc"><p>Get note path from sort field text.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def get_note_path(sort_field_text: str, deck_dir: ExtantDir) -&gt; ExtantFile:
    &#34;&#34;&#34;Get note path from sort field text.&#34;&#34;&#34;
    field_text = sort_field_text

    # Construct filename, stripping HTML tags and sanitizing (quickly).
    field_text = plain_to_html(field_text)
    field_text = re.sub(&#34;&lt;[^&lt;]+?&gt;&#34;, &#34;&#34;, field_text)

    # If the HTML stripping removed all text, we just slugify the raw sort
    # field text.
    if len(field_text) == 0:
        field_text = sort_field_text

    name = field_text[:MAX_FIELNAME_LEN]
    slug = F.slugify(name, allow_unicode=True)

    # Make it so `slug` cannot possibly be an empty string, because then we get
    # a `Path(&#39;.&#39;)` which is a bug, and causes a runtime exception.  If all
    # else fails, generate a random hex string to use as the filename.
    if len(slug) == 0:
        slug = secrets.token_hex(10)
        logger.warning(f&#34;Slug for {name} is empty. Using {slug} as filename&#34;)

    filename = Path(slug)
    filename = filename.with_suffix(MD)
    note_path = F.test(deck_dir / filename)

    i = 1
    while not isinstance(note_path, NoPath):
        filename = Path(f&#34;{name}_{i}&#34;).with_suffix(MD)
        note_path = F.test(deck_dir / filename)
        i += 1

    note_path: ExtantFile = F.touch(deck_dir, str(filename))

    return note_path</code></pre>
</details>
</dd>
<dt id="ki.get_note_payload"><code class="name flex">
<span>def <span class="ident">get_note_payload</span></span>(<span>colnote: <a title="ki.types.ColNote" href="types.html#ki.types.ColNote">ColNote</a>, paths: dict[str, <a title="ki.types.ExtantFile" href="types.html#ki.types.ExtantFile">ExtantFile</a>]) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return the markdown-converted contents of the Anki note represented by
<code>colnote</code> as a string.</p>
<p>Given a <code>ColNote</code>, which is a dataclass wrapper around a <code>Note</code> object
which has been loaded from the DB, and a mapping from <code>fid</code>s (unique
identifiers of field-note pairs) to paths, we check for each field of each
note whether that field's <code>fid</code> is contained in <code>paths</code>. If so, that means
that the caller dumped the contents of this field to a file (the file with
this path, in fact) in order to autoformat the HTML source. If this field
was tidied/autoformatted, we read from that path to get the tidied source,
otherwise, we use the field content present in the <code>ColNote</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def get_note_payload(colnote: ColNote, paths: Dict[str, ExtantFile]) -&gt; str:
    &#34;&#34;&#34;
    Return the markdown-converted contents of the Anki note represented by
    `colnote` as a string.

    Given a `ColNote`, which is a dataclass wrapper around a `Note` object
    which has been loaded from the DB, and a mapping from `fid`s (unique
    identifiers of field-note pairs) to paths, we check for each field of each
    note whether that field&#39;s `fid` is contained in `paths`. If so, that means
    that the caller dumped the contents of this field to a file (the file with
    this path, in fact) in order to autoformat the HTML source. If this field
    was tidied/autoformatted, we read from that path to get the tidied source,
    otherwise, we use the field content present in the `ColNote`.
    &#34;&#34;&#34;
    # Get tidied html if it exists.
    tidyfields = {}
    for field_name, field_text in colnote.n.items():
        fid = get_field_note_id(colnote.n.id, field_name)
        if fid in paths:
            tidyfields[field_name] = paths[fid].read_text()
        else:
            tidyfields[field_name] = field_text

    # TODO: Make this use `get_colnote_repr()`.
    # Construct note repr from tidyfields map.
    lines = get_header_lines(colnote)
    for field_name, field_text in tidyfields.items():
        lines.append(&#34;### &#34; + field_name)
        lines.append(html_to_screen(field_text))
        lines.append(&#34;&#34;)

    return &#34;\n&#34;.join(lines)</code></pre>
</details>
</dd>
<dt id="ki.get_target"><code class="name flex">
<span>def <span class="ident">get_target</span></span>(<span>cwd: <a title="ki.types.ExtantDir" href="types.html#ki.types.ExtantDir">ExtantDir</a>, col_file: <a title="ki.types.ExtantFile" href="types.html#ki.types.ExtantFile">ExtantFile</a>, directory: str) ‑> Union[result.result.Ok[<a title="ki.types.EmptyDir" href="types.html#ki.types.EmptyDir">EmptyDir</a>], result.result.Err[Exception]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@monadic
@beartype
def get_target(
    cwd: ExtantDir, col_file: ExtantFile, directory: str
) -&gt; Result[EmptyDir, Exception]:
    # Create default target directory.
    path = F.test(Path(directory) if directory != &#34;&#34; else cwd / col_file.stem)
    if isinstance(path, NoPath):
        path.mkdir(parents=True)
        return M.emptydir(path)
    if isinstance(path, EmptyDir):
        return Ok(path)
    return Err(TargetExistsError(path))</code></pre>
</details>
</dd>
<dt id="ki.git_subprocess_pull"><code class="name flex">
<span>def <span class="ident">git_subprocess_pull</span></span>(<span>remote: str, branch: str) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Pull remote into branch using a subprocess call.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def git_subprocess_pull(remote: str, branch: str) -&gt; int:
    &#34;&#34;&#34;Pull remote into branch using a subprocess call.&#34;&#34;&#34;
    p = subprocess.run(
        [
            &#34;git&#34;,
            &#34;pull&#34;,
            &#34;-v&#34;,
            &#34;--allow-unrelated-histories&#34;,
            &#34;--strategy-option&#34;,
            &#34;theirs&#34;,
            remote,
            branch,
        ],
        check=False,
        capture_output=True,
    )
    pull_stderr = p.stderr.decode()
    logger.debug(f&#34;\n{pull_stderr}&#34;)
    logger.debug(f&#34;Return code: {p.returncode}&#34;)
    if p.returncode != 0:
        raise ValueError(pull_stderr)
    return p.returncode</code></pre>
</details>
</dd>
<dt id="ki.html_to_screen"><code class="name flex">
<span>def <span class="ident">html_to_screen</span></span>(<span>html: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Convert html for printing to screen.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def html_to_screen(html: str) -&gt; str:
    &#34;&#34;&#34;Convert html for printing to screen.&#34;&#34;&#34;
    html = re.sub(r&#34;\&lt;style\&gt;.*\&lt;\/style\&gt;&#34;, &#34;&#34;, html, flags=re.S)

    generated = GENERATED_HTML_SENTINEL in html
    if generated:
        plain = html_to_markdown(html)
        if html != markdown_to_html(plain):
            html_clean = re.sub(r&#39; data-original-markdown=&#34;[^&#34;]*&#34;&#39;, &#34;&#34;, html)
            plain += (
                &#34;\n\n### Current HTML → Markdown\n&#34;
                f&#34;{markdownify.markdownify(html_clean)}&#34;
            )
            plain += f&#34;\n### Current HTML\n{html_clean}&#34;
    else:
        plain = html

    # For convenience: Un-escape some common LaTeX constructs
    plain = plain.replace(r&#34;\\\\&#34;, r&#34;\\&#34;)
    plain = plain.replace(r&#34;\\{&#34;, r&#34;\{&#34;)
    plain = plain.replace(r&#34;\\}&#34;, r&#34;\}&#34;)
    plain = plain.replace(r&#34;\*}&#34;, r&#34;*}&#34;)

    plain = plain.replace(r&#34;&amp;lt;&#34;, &#34;&lt;&#34;)
    plain = plain.replace(r&#34;&amp;gt;&#34;, &#34;&gt;&#34;)
    plain = plain.replace(r&#34;&amp;amp;&#34;, &#34;&amp;&#34;)
    plain = plain.replace(r&#34;&amp;nbsp;&#34;, &#34; &#34;)

    plain = plain.replace(&#34;&lt;br&gt;&#34;, &#34;\n&#34;)
    plain = plain.replace(&#34;&lt;br/&gt;&#34;, &#34;\n&#34;)
    plain = plain.replace(&#34;&lt;br /&gt;&#34;, &#34;\n&#34;)
    plain = plain.replace(&#34;&lt;div&gt;&#34;, &#34;\n&#34;)
    plain = plain.replace(&#34;&lt;/div&gt;&#34;, &#34;&#34;)

    # For convenience: Fix mathjax escaping (but only if the html is generated)
    if generated:
        plain = plain.replace(r&#34;\[&#34;, r&#34;[&#34;)
        plain = plain.replace(r&#34;\]&#34;, r&#34;]&#34;)
        plain = plain.replace(r&#34;\(&#34;, r&#34;(&#34;)
        plain = plain.replace(r&#34;\)&#34;, r&#34;)&#34;)

    plain = re.sub(r&#34;\&lt;b\&gt;\s*\&lt;\/b\&gt;&#34;, &#34;&#34;, plain)
    return plain.strip()</code></pre>
</details>
</dd>
<dt id="ki.init_repos"><code class="name flex">
<span>def <span class="ident">init_repos</span></span>(<span>targetdir: <a title="ki.types.ExtantDir" href="types.html#ki.types.ExtantDir">ExtantDir</a>, leaves: <a title="ki.types.Leaves" href="types.html#ki.types.Leaves">Leaves</a>, msg: str) ‑> Union[result.result.Ok[bool], result.result.Err[Exception]]</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize both git repos and commit contents of the main one.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@monadic
@beartype
def init_repos(
    targetdir: ExtantDir, leaves: Leaves, msg: str
) -&gt; Result[bool, Exception]:
    &#34;&#34;&#34;
    Initialize both git repos and commit contents of the main one.
    &#34;&#34;&#34;
    repo = git.Repo.init(targetdir, initial_branch=BRANCH_NAME)
    repo.git.add(all=True)
    _ = repo.index.commit(msg)

    # Initialize the copy of the repository with submodules replaced with
    # subdirectories that lives in `.ki/no_submodules_tree/`.
    _ = git.Repo.init(leaves.dirs[NO_SM_DIR], initial_branch=BRANCH_NAME)

    return Ok()</code></pre>
</details>
</dd>
<dt id="ki.is_anki_note"><code class="name flex">
<span>def <span class="ident">is_anki_note</span></span>(<span>path: <a title="ki.types.ExtantFile" href="types.html#ki.types.ExtantFile">ExtantFile</a>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if file is an <code>apy</code>-style markdown anki note.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def is_anki_note(path: ExtantFile) -&gt; bool:
    &#34;&#34;&#34;Check if file is an `apy`-style markdown anki note.&#34;&#34;&#34;
    path = str(path)

    # Ought to have markdown file extension.
    if path[-3:] != &#34;.md&#34;:
        return False
    with open(path, &#34;r&#34;, encoding=&#34;UTF-8&#34;) as md_f:
        lines = md_f.readlines()
    if len(lines) &lt; 2:
        return False
    if lines[0] != &#34;## Note\n&#34;:
        return False
    if not re.match(r&#34;^nid: [0-9]+$&#34;, lines[1]):
        return False
    return True</code></pre>
</details>
</dd>
<dt id="ki.lock"><code class="name flex">
<span>def <span class="ident">lock</span></span>(<span>kirepo: <a title="ki.types.KiRepo" href="types.html#ki.types.KiRepo">KiRepo</a>) ‑> sqlite3.Connection</span>
</code></dt>
<dd>
<div class="desc"><p>Acquire a lock on a SQLite3 database given a path.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def lock(kirepo: KiRepo) -&gt; sqlite3.Connection:
    &#34;&#34;&#34;Acquire a lock on a SQLite3 database given a path.&#34;&#34;&#34;
    con = sqlite3.connect(kirepo.col_file)
    con.isolation_level = &#34;EXCLUSIVE&#34;
    con.execute(&#34;BEGIN EXCLUSIVE&#34;)
    return con</code></pre>
</details>
</dd>
<dt id="ki.parse_markdown_note"><code class="name flex">
<span>def <span class="ident">parse_markdown_note</span></span>(<span>parser: lark.lark.Lark, transformer: <a title="ki.transformer.NoteTransformer" href="transformer.html#ki.transformer.NoteTransformer">NoteTransformer</a>, notes_file: <a title="ki.types.ExtantFile" href="types.html#ki.types.ExtantFile">ExtantFile</a>) ‑> <a title="ki.transformer.FlatNote" href="transformer.html#ki.transformer.FlatNote">FlatNote</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse with lark.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def parse_markdown_note(
    parser: Lark, transformer: NoteTransformer, notes_file: ExtantFile
) -&gt; FlatNote:
    &#34;&#34;&#34;Parse with lark.&#34;&#34;&#34;
    tree = parser.parse(notes_file.read_text(encoding=&#34;UTF-8&#34;))
    flatnotes: List[FlatNote] = transformer.transform(tree)

    # UNSAFE!
    return flatnotes[0]</code></pre>
</details>
</dd>
<dt id="ki.parse_notetype_dict"><code class="name flex">
<span>def <span class="ident">parse_notetype_dict</span></span>(<span>nt: dict[str, typing.Any]) ‑> Union[result.result.Ok[<a title="ki.types.Notetype" href="types.html#ki.types.Notetype">Notetype</a>], result.result.Err[Exception]]</span>
</code></dt>
<dd>
<div class="desc"><p>Convert an Anki NotetypeDict into a Notetype dataclass.</p>
<p>Anki returns objects of type <code>NotetypeDict</code> (see pylib/anki/models.py)
when you call a method like <code>col.models.all()</code>. This is a dictionary
mapping strings to various stuff, and we read all its data into a python
dataclass here so that we can access it safely. Since we don't expect Anki
to ever give us 'invalid' notetypes (since we define 'valid' as being
processable by Anki), we return an exception if the parse fails.</p>
<p>Note on naming convention: Below, abbreviated variable names represent
dicts coming from Anki, like <code>nt: NotetypeDict</code> or <code>fld: FieldDict</code>.
Full words like <code>field: Field</code> represent ki dataclasses. The parameters
of the dataclasses, however, use abbreviations for consistency with Anki
map keys.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def parse_notetype_dict(nt: Dict[str, Any]) -&gt; Result[Notetype, Exception]:
    &#34;&#34;&#34;
    Convert an Anki NotetypeDict into a Notetype dataclass.

    Anki returns objects of type `NotetypeDict` (see pylib/anki/models.py)
    when you call a method like `col.models.all()`. This is a dictionary
    mapping strings to various stuff, and we read all its data into a python
    dataclass here so that we can access it safely. Since we don&#39;t expect Anki
    to ever give us &#39;invalid&#39; notetypes (since we define &#39;valid&#39; as being
    processable by Anki), we return an exception if the parse fails.

    Note on naming convention: Below, abbreviated variable names represent
    dicts coming from Anki, like `nt: NotetypeDict` or `fld: FieldDict`.
    Full words like `field: Field` represent ki dataclasses. The parameters
    of the dataclasses, however, use abbreviations for consistency with Anki
    map keys.
    &#34;&#34;&#34;
    try:
        fields: Dict[int, Field] = {}
        for fld in nt[&#34;flds&#34;]:
            ordinal = fld[&#34;ord&#34;]
            fields[ordinal] = Field(name=fld[&#34;name&#34;], ord=ordinal)

        templates: List[Template] = []
        for tmpl in nt[&#34;tmpls&#34;]:
            templates.append(
                Template(
                    name=tmpl[&#34;name&#34;],
                    qfmt=tmpl[&#34;qfmt&#34;],
                    afmt=tmpl[&#34;afmt&#34;],
                    ord=tmpl[&#34;ord&#34;],
                )
            )

        # Guarantee that &#39;sortf&#39; exists in `notetype.flds`.
        sort_ordinal: int = nt[&#34;sortf&#34;]
        if sort_ordinal not in fields:
            return Err(MissingFieldOrdinalError)

        notetype = Notetype(
            id=nt[&#34;id&#34;],
            name=nt[&#34;name&#34;],
            type=nt[&#34;type&#34;],
            flds=list(fields.values()),
            tmpls=templates,
            sortf=fields[sort_ordinal],
            dict=copy.deepcopy(nt),
        )

    except KeyError as err:
        return Err(err)
    return Ok(notetype)</code></pre>
</details>
</dd>
<dt id="ki.pull_changes_from_remote_repo"><code class="name flex">
<span>def <span class="ident">pull_changes_from_remote_repo</span></span>(<span>kirepo: <a title="ki.types.KiRepo" href="types.html#ki.types.KiRepo">KiRepo</a>, anki_remote_root: <a title="ki.types.ExtantDir" href="types.html#ki.types.ExtantDir">ExtantDir</a>, last_push_repo: git.repo.base.Repo, md5sum: str, _cloned: str) ‑> Union[result.result.Ok[bool], result.result.Err[Exception]]</span>
</code></dt>
<dd>
<div class="desc"><p>Load the git repository at <code>anki_remote_root</code>, force pull (preferring
'theirs', i.e. the new stuff from the sqlite3 database) changes from that
repository (which is cloned straight from the collection, which in general
may have new changes) into <code>last_push_repo</code>, and then pull
<code>last_push_repo</code> into the main repository.</p>
<p>We pull in this sequence in order to avoid merge conflicts. Since we first
pull into a snapshot of the repository as it looked when we last pushed to
the database, we know that there cannot be any merge conflicts, because to
git, it just looks like we haven't made any changes since then. Then we
pull the result of that merge into our actual repository. So there could
still be merge conflicts at that point, but they will only be 'genuine'
merge conflicts in some sense, because as a result of using this snapshot
strategy, we give the anki collection the appearance of being a persistent
remote git repo. If we didn't do this, the fact that we did a fresh clone
of the database every time would mean that everything would look like a
merge conflict, because there is no shared history.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@monadic
@beartype
def pull_changes_from_remote_repo(
    kirepo: KiRepo,
    anki_remote_root: ExtantDir,
    last_push_repo: git.Repo,
    md5sum: str,
    _cloned: str,
) -&gt; Result[bool, Exception]:
    &#34;&#34;&#34;
    Load the git repository at `anki_remote_root`, force pull (preferring
    &#39;theirs&#39;, i.e. the new stuff from the sqlite3 database) changes from that
    repository (which is cloned straight from the collection, which in general
    may have new changes) into `last_push_repo`, and then pull
    `last_push_repo` into the main repository.

    We pull in this sequence in order to avoid merge conflicts. Since we first
    pull into a snapshot of the repository as it looked when we last pushed to
    the database, we know that there cannot be any merge conflicts, because to
    git, it just looks like we haven&#39;t made any changes since then. Then we
    pull the result of that merge into our actual repository. So there could
    still be merge conflicts at that point, but they will only be &#39;genuine&#39;
    merge conflicts in some sense, because as a result of using this snapshot
    strategy, we give the anki collection the appearance of being a persistent
    remote git repo. If we didn&#39;t do this, the fact that we did a fresh clone
    of the database every time would mean that everything would look like a
    merge conflict, because there is no shared history.
    &#34;&#34;&#34;
    remote_repo: Res[git.Repo] = M.repo(anki_remote_root)
    if remote_repo.is_err():
        return remote_repo
    remote_repo: git.Repo = remote_repo.unwrap()

    # Create git remote pointing to anki remote repo.
    anki_remote = last_push_repo.create_remote(REMOTE_NAME, remote_repo.git_dir)

    # Pull anki remote repo into `last_push_repo`.
    last_push_root: Res[ExtantDir] = F.working_dir(last_push_repo)
    pulled: OkErr = pull_theirs_from_remote(last_push_repo, last_push_root, anki_remote)
    if pulled.is_err():
        return pulled

    # Create remote pointing to `last_push` repo and pull into `repo`.
    last_push_remote = kirepo.repo.create_remote(REMOTE_NAME, last_push_repo.git_dir)
    kirepo.repo.git.config(&#34;pull.rebase&#34;, &#34;false&#34;)
    p = subprocess.run(
        [&#34;git&#34;, &#34;pull&#34;, &#34;-v&#34;, REMOTE_NAME, BRANCH_NAME],
        check=False,
        capture_output=True,
    )
    click.secho(f&#34;{p.stdout.decode()}&#34;, bold=True)
    click.secho(f&#34;{p.stderr.decode()}&#34;, bold=True)
    kirepo.repo.delete_remote(last_push_remote)

    # Append to hashes file.
    append_md5sum(kirepo.ki_dir, kirepo.col_file.name, md5sum, silent=True)

    # Check that md5sum hasn&#39;t changed.
    if F.md5(kirepo.col_file) != md5sum:
        return Err(CollectionChecksumError(kirepo.col_file))
    return Ok()</code></pre>
</details>
</dd>
<dt id="ki.pull_theirs_from_remote"><code class="name flex">
<span>def <span class="ident">pull_theirs_from_remote</span></span>(<span>repo: git.repo.base.Repo, root: <a title="ki.types.ExtantDir" href="types.html#ki.types.ExtantDir">ExtantDir</a>, remote: git.remote.Remote) ‑> Union[result.result.Ok[bool], result.result.Err[Exception]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@monadic
@beartype
def pull_theirs_from_remote(
    repo: git.Repo, root: ExtantDir, remote: git.Remote
) -&gt; Result[bool, Exception]:
    cwd: ExtantDir = F.chdir(root)
    echo(f&#34;Pulling into {root}&#34;)
    repo.git.config(&#34;pull.rebase&#34;, &#34;false&#34;)
    # TODO: This is not yet safe. Consider rewriting with gitpython.
    git_subprocess_pull(REMOTE_NAME, BRANCH_NAME)
    repo.delete_remote(remote)
    F.chdir(cwd)
    return Ok()</code></pre>
</details>
</dd>
<dt id="ki.push_deltas"><code class="name flex">
<span>def <span class="ident">push_deltas</span></span>(<span>deltas: list[<a title="ki.types.Delta" href="types.html#ki.types.Delta">Delta</a>], models: dict[str, <a title="ki.types.Notetype" href="types.html#ki.types.Notetype">Notetype</a>], kirepo: <a title="ki.types.KiRepo" href="types.html#ki.types.KiRepo">KiRepo</a>, md5sum: str, parser: lark.lark.Lark, transformer: <a title="ki.transformer.NoteTransformer" href="transformer.html#ki.transformer.NoteTransformer">NoteTransformer</a>, stage_kirepo: <a title="ki.types.KiRepo" href="types.html#ki.types.KiRepo">KiRepo</a>, con: sqlite3.Connection) ‑> Union[result.result.Ok[bool], result.result.Err[Exception]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@monadic
@beartype
def push_deltas(
    deltas: List[Delta],
    models: Dict[str, Notetype],
    kirepo: KiRepo,
    md5sum: str,
    parser: Lark,
    transformer: NoteTransformer,
    stage_kirepo: KiRepo,
    con: sqlite3.Connection,
) -&gt; Result[bool, Exception]:

    # If there are no changes, quit.
    if len(set(deltas)) == 0:
        echo(&#34;ki push: up to date.&#34;)
        return Ok()

    echo(f&#34;Pushing to &#39;{kirepo.col_file}&#39;&#34;)
    echo(f&#34;Computed md5sum: {md5sum}&#34;)
    echo(f&#34;Verified md5sum matches latest hash in &#39;{kirepo.hashes_file}&#39;&#34;)

    # Copy collection to a temp directory.
    temp_col_dir: ExtantDir = F.mkdtemp()
    new_col_file = temp_col_dir / kirepo.col_file.name
    col_name: str = kirepo.col_file.name
    new_col_file: ExtantFile = F.copyfile(kirepo.col_file, temp_col_dir, col_name)

    head: Res[RepoRef] = M.head_repo_ref(kirepo.repo)
    if head.is_err():
        echo(&#34;Failed: no commits in repository. Couldn&#39;t find HEAD ref.&#34;)
        return Ok()
    head = head.unwrap()
    echo(f&#34;Generating local .anki2 file from latest commit: {head.sha}&#34;)
    echo(f&#34;Writing changes to &#39;{new_col_file}&#39;...&#34;)

    cwd: ExtantDir = F.cwd()
    col = Collection(new_col_file)
    F.chdir(cwd)
    modified = True

    # Add all new models.
    for model in models.values():

        # TODO: Consider waiting to parse `models` until after the
        # `add_dict()` call.
        if col.models.id_for_name(model.name) is not None:

            nt_copy: NotetypeDict = copy.deepcopy(model.dict)
            nt_copy[&#34;id&#34;] = 0
            changes: OpChangesWithId = col.models.add_dict(nt_copy)
            nt: NotetypeDict = col.models.get(changes.id)
            model: OkErr = parse_notetype_dict(nt)
            if model.is_err():
                return model

    # Gather logging statements to display.
    log: List[str] = []

    # Stash both unstaged and staged files (including untracked).
    kirepo.repo.git.stash(include_untracked=True, keep_index=True)
    kirepo.repo.git.reset(&#34;HEAD&#34;, hard=True)

    is_delete = lambda d: d.status == GitChangeType.DELETED
    deletes: List[Delta] = list(filter(is_delete, deltas))
    logger.debug(f&#34;Deleting {len(deletes)} notes.&#34;)

    for delta in tqdm(deltas, ncols=TQDM_NUM_COLS):

        # Parse the file at `delta.path` into a `FlatNote`, and
        # add/edit/delete in collection.
        flatnote = parse_markdown_note(parser, transformer, delta.path)
        logger.debug(f&#34;Resolving delta:\n{pp.pformat(delta)}\n{pp.pformat(flatnote)}&#34;)

        if is_delete(delta):
            logger.debug(f&#34;Deleting note {flatnote.nid}&#34;)
            col.remove_notes([flatnote.nid])
            continue

        # If a note with this nid exists in DB, update it.
        # TODO: If relevant prefix of sort field has changed, we regenerate
        # the file. Recall that the sort field is used to determine the
        # filename. If the content of the sort field has changed, then we
        # may need to update the filename.
        colnote: OkErr = push_flatnote_to_anki(col, flatnote)
        regenerated: OkErr = regenerate_note_file(colnote, kirepo.root, delta.relpath)
        if regenerated.is_err():
            regen_err: Exception = regenerated.unwrap_err()
            if isinstance(regen_err, Warning):
                continue
            return regenerated
        log += regenerated.unwrap()

    # Commit nid reassignments.
    logger.warning(f&#34;Reassigned {len(log)} nids.&#34;)
    if len(log) &gt; 0:
        msg = &#34;Generated new nid(s).\n\n&#34; + &#34;\n&#34;.join(log)

        # Commit in all submodules (doesn&#39;t support recursing yet).
        for sm in kirepo.repo.submodules:

            # TODO: Remove submodule update calls, and use the gitpython
            # API to check if the submodules exist instead. The update
            # calls make a remote fetch which takes an extremely long time,
            # and the user should have run `git submodule update`
            # themselves anyway.
            subrepo: git.Repo = sm.update().module()
            subrepo.git.add(all=True)
            subrepo.index.commit(msg)

        # Commit in main repository.
        kirepo.repo.git.add(all=True)
        _ = kirepo.repo.index.commit(msg)

    if modified:
        echo(&#34;Database was modified.&#34;)
        col.close()
    elif col.db:
        col.close(False)

    # Backup collection file and overwrite collection.
    backup(kirepo)
    new_col_file = F.copyfile(new_col_file, F.parent(kirepo.col_file), col_name)
    echo(f&#34;Overwrote &#39;{kirepo.col_file}&#39;&#34;)

    # Append to hashes file.
    new_md5sum = F.md5(new_col_file)
    append_md5sum(kirepo.ki_dir, new_col_file.name, new_md5sum, silent=False)

    # Completely annihilate the `.ki/no_submodules_tree`
    # directory/repository, and replace it with `stage_kirepo`. This is a
    # sensible operation because earlier, we copied the `.git/` directory
    # from `.ki/no_submodules_tree` to the staging repo. So the history is
    # preserved.
    no_modules_root: NoPath = F.rmtree(F.working_dir(kirepo.no_modules_repo))
    F.copytree(stage_kirepo.root, no_modules_root)

    # Dump HEAD ref of current repo in `.ki/last_push`.
    kirepo.last_push_file.write_text(head.sha)

    # Unlock Anki SQLite DB.
    unlock(con)

    return Ok()</code></pre>
</details>
</dd>
<dt id="ki.push_flatnote_to_anki"><code class="name flex">
<span>def <span class="ident">push_flatnote_to_anki</span></span>(<span>col: anki.collection.Collection, flatnote: <a title="ki.transformer.FlatNote" href="transformer.html#ki.transformer.FlatNote">FlatNote</a>) ‑> Union[result.result.Ok[<a title="ki.types.ColNote" href="types.html#ki.types.ColNote">ColNote</a>], result.result.Err[Exception]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@monadic
@beartype
def push_flatnote_to_anki(
    col: Collection, flatnote: FlatNote
) -&gt; Result[ColNote, Exception]:
    model_id: Optional[int] = col.models.id_for_name(flatnote.model)
    if model_id is None:
        return Err(MissingNotetypeError(flatnote.model))

    new = False
    note: Note
    try:
        note = col.get_note(flatnote.nid)
    except anki.errors.NotFoundError:
        logger.debug(f&#34;Failed to find &#39;{flatnote.nid}&#39;&#34;)
        note = col.new_note(model_id)
        col.add_note(note, col.decks.id(flatnote.deck, create=True))
        logger.debug(f&#34;Got new nid &#39;{note.id}&#39;&#34;)
        new = True

    old_notetype: Res[Notetype] = parse_notetype_dict(note.note_type())
    new_notetype: Res[Notetype] = parse_notetype_dict(col.models.get(model_id))

    note: OkErr = update_note(note, flatnote, old_notetype, new_notetype)
    if note.is_err():
        return note

    note: Note = note.unwrap()
    new_notetype: Notetype = new_notetype.unwrap()

    # Get sort field content.
    try:
        sortf_text: str = note[new_notetype.sortf.name]
    except KeyError as err:
        return Err(err)

    colnote = ColNote(
        n=note,
        new=new,
        deck=flatnote.deck,
        title=flatnote.title,
        old_nid=flatnote.nid,
        markdown=flatnote.markdown,
        notetype=new_notetype,
        sortf_text=sortf_text,
    )
    return Ok(colnote)</code></pre>
</details>
</dd>
<dt id="ki.regenerate_note_file"><code class="name flex">
<span>def <span class="ident">regenerate_note_file</span></span>(<span>colnote: <a title="ki.types.ColNote" href="types.html#ki.types.ColNote">ColNote</a>, root: <a title="ki.types.ExtantDir" href="types.html#ki.types.ExtantDir">ExtantDir</a>, relpath: pathlib.Path) ‑> Union[result.result.Ok[list[str]], result.result.Err[Exception]]</span>
</code></dt>
<dd>
<div class="desc"><p>Construct the contents of a note corresponding to the arguments <code>colnote</code>,
which itself was created from <code>flatnote</code>, and then write it to disk.</p>
<p>Returns a list of lines to add to the commit message (either an empty list,
or a list containing a single line).</p>
<p>This function is intended to be used when we are adding <em>completely</em> new
notes, in which case the caller generates a new note with a newly generated
nid, which can be accessed at <code>colnote.n.id</code>. In general, this is the
branch taken whenever Anki fails to recognize the nid given in the note
file, which can be accessed via <code>colnote.old_nid</code>. Thus, we only regenerate
if <code>colnote.n.id</code> and <code>colnote.old_nid</code> to differ, since the former has the
newly assigned nid for this note, yielded by the Anki runtime, and the
latter has whatever was written in the file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@monadic
@beartype
def regenerate_note_file(
    colnote: ColNote, root: ExtantDir, relpath: Path
) -&gt; Result[List[str], Exception]:
    &#34;&#34;&#34;
    Construct the contents of a note corresponding to the arguments `colnote`,
    which itself was created from `flatnote`, and then write it to disk.

    Returns a list of lines to add to the commit message (either an empty list,
    or a list containing a single line).

    This function is intended to be used when we are adding *completely* new
    notes, in which case the caller generates a new note with a newly generated
    nid, which can be accessed at `colnote.n.id`. In general, this is the
    branch taken whenever Anki fails to recognize the nid given in the note
    file, which can be accessed via `colnote.old_nid`. Thus, we only regenerate
    if `colnote.n.id` and `colnote.old_nid` to differ, since the former has the
    newly assigned nid for this note, yielded by the Anki runtime, and the
    latter has whatever was written in the file.
    &#34;&#34;&#34;
    # If this is not a new note, then we didn&#39;t reassign its nid, and we don&#39;t
    # need to regenerate the file. So we don&#39;t add a line to the commit
    # message.
    if not colnote.new:
        return Ok([])

    # Get paths to note in local repo, as distinct from staging repo.
    repo_note_path: Path = root / relpath

    # If this is not an entirely new file, remove it.
    if repo_note_path.is_file():
        repo_note_path.unlink()

    parent: ExtantDir = F.force_mkdir(repo_note_path.parent)
    new_note_path: ExtantFile = get_note_path(colnote.sortf_text, parent)
    new_note_path.write_text(get_colnote_repr(colnote), encoding=&#34;UTF-8&#34;)

    # TODO: Figure out if this still works if we use pathlib instead.
    new_note_relpath = os.path.relpath(new_note_path, root)

    msg = f&#34;Reassigned nid: &#39;{colnote.old_nid}&#39; -&gt; &#39;{colnote.n.id}&#39; in &#39;{new_note_relpath}&#39;&#34;
    return Ok([msg])</code></pre>
</details>
</dd>
<dt id="ki.tidy_html_recursively"><code class="name flex">
<span>def <span class="ident">tidy_html_recursively</span></span>(<span>root: <a title="ki.types.ExtantDir" href="types.html#ki.types.ExtantDir">ExtantDir</a>, silent: bool) ‑> Union[result.result.Ok[bool], result.result.Err[Exception]]</span>
</code></dt>
<dd>
<div class="desc"><p>Call html5-tidy on each file in <code>root</code>, editing in-place.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@monadic
@beartype
def tidy_html_recursively(root: ExtantDir, silent: bool) -&gt; Result[bool, Exception]:
    &#34;&#34;&#34;Call html5-tidy on each file in `root`, editing in-place.&#34;&#34;&#34;
    # Spin up subprocesses for tidying field HTML in-place.
    batches: List[List[ExtantFile]] = list(F.get_batches(F.rglob(root, &#34;*&#34;), BATCH_SIZE))
    for batch in tqdm(batches, ncols=TQDM_NUM_COLS, disable=silent):

        # Fail silently here, so as to not bother user with tidy warnings.
        command = [&#34;tidy&#34;, &#34;-q&#34;, &#34;-m&#34;, &#34;-i&#34;, &#34;-omit&#34;, &#34;-utf8&#34;, &#34;--tidy-mark&#34;, &#34;no&#34;]
        command += batch
        try:
            subprocess.run(command, check=False, capture_output=True)
        except Exception as err:
            return Err(err)
    return Ok()</code></pre>
</details>
</dd>
<dt id="ki.unlock"><code class="name flex">
<span>def <span class="ident">unlock</span></span>(<span>con: sqlite3.Connection) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Unlock a SQLite3 database.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def unlock(con: sqlite3.Connection) -&gt; bool:
    &#34;&#34;&#34;Unlock a SQLite3 database.&#34;&#34;&#34;
    con.commit()
    con.close()
    return True</code></pre>
</details>
</dd>
<dt id="ki.unsubmodule_repo"><code class="name flex">
<span>def <span class="ident">unsubmodule_repo</span></span>(<span>repo: git.repo.base.Repo) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Un-submodule all the git submodules (convert to ordinary subdirectories and
destroy commit history).</p>
<p>MUTATES REPO in-place!</p>
<p>UNSAFE: git.rm() calls.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def unsubmodule_repo(repo: git.Repo) -&gt; None:
    &#34;&#34;&#34;
    Un-submodule all the git submodules (convert to ordinary subdirectories and
    destroy commit history).

    MUTATES REPO in-place!

    UNSAFE: git.rm() calls.
    &#34;&#34;&#34;
    gitmodules_path: Path = Path(repo.working_dir) / GITMODULES_FILE
    for sm in repo.submodules:

        # Untrack, remove gitmodules file, remove .git file, and add directory back.
        sm.update()

        # Guaranteed to exist by gitpython.
        sm_path = Path(sm.module().working_tree_dir)
        repo.git.rm(sm_path, cached=True)

        # May not exist.
        repo.git.rm(gitmodules_path)

        # Guaranteed to exist by gitpython, and safe because we pass
        # `missing_ok=True`, which means no error is raised.
        (sm_path / GIT).unlink(missing_ok=True)

        # Should still exist after git.rm().
        repo.git.add(sm_path)
        _ = repo.index.commit(f&#34;Add submodule {sm.name} as ordinary directory.&#34;)

    if gitmodules_path.exists():
        repo.git.rm(gitmodules_path)
        _ = repo.index.commit(&#34;Remove &#39;.gitmodules&#39; file.&#34;)</code></pre>
</details>
</dd>
<dt id="ki.update_note"><code class="name flex">
<span>def <span class="ident">update_note</span></span>(<span>note: anki.notes.Note, flatnote: <a title="ki.transformer.FlatNote" href="transformer.html#ki.transformer.FlatNote">FlatNote</a>, old_notetype: <a title="ki.types.Notetype" href="types.html#ki.types.Notetype">Notetype</a>, new_notetype: <a title="ki.types.Notetype" href="types.html#ki.types.Notetype">Notetype</a>) ‑> Union[result.result.Ok[anki.notes.Note], result.result.Err[Exception]]</span>
</code></dt>
<dd>
<div class="desc"><p>Change all the data of <code>note</code> to that given in <code>flatnote</code>.</p>
<p>This is only to be called on notes whose nid already exists in the
database.
Creates a new deck if <code>flatnote.deck</code> doesn't exist.
Assumes
that the model has already been added to the collection, and raises an
exception if it finds otherwise.
Changes notetype to that specified by
<code>flatnote.model</code>.
Overwrites all fields with <code>flatnote.fields</code>.</p>
<p>Updates:
- tags
- deck
- model
- fields</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@monadic
@beartype
def update_note(
    note: Note, flatnote: FlatNote, old_notetype: Notetype, new_notetype: Notetype
) -&gt; Result[Note, Exception]:
    &#34;&#34;&#34;
    Change all the data of `note` to that given in `flatnote`.

    This is only to be called on notes whose nid already exists in the
    database.  Creates a new deck if `flatnote.deck` doesn&#39;t exist.  Assumes
    that the model has already been added to the collection, and raises an
    exception if it finds otherwise.  Changes notetype to that specified by
    `flatnote.model`.  Overwrites all fields with `flatnote.fields`.

    Updates:
    - tags
    - deck
    - model
    - fields
    &#34;&#34;&#34;

    # Check that the passed argument `new_notetype` has a name consistent with
    # the model specified in `flatnote`. The former should be derived from the
    # latter, and if they don&#39;t match, there is a bug in the caller.
    if flatnote.model != new_notetype.name:
        return Err(NotetypeMismatchError(flatnote, new_notetype))

    note.tags = flatnote.tags
    note.flush()

    # Set the deck of the given note, and create a deck with this name if it
    # doesn&#39;t already exist. See the comments/docstrings in the implementation.
    newdid: int = note.col.decks.id(flatnote.deck, create=True)
    cids = [c.id for c in note.cards()]

    # Set deck for all cards of this note.
    if cids:
        note.col.set_deck(cids, newdid)

    # Change notetype of note.
    fmap: Dict[str, None] = {}
    for field in old_notetype.flds:
        fmap[field.ord] = None
    note.col.models.change(old_notetype.dict, [note.id], new_notetype.dict, fmap, None)
    note.load()

    # Validate field keys against notetype.
    validated: OkErr = validate_flatnote_fields(new_notetype, flatnote)
    if validated.is_err():
        # TODO: Decide where warnings should be printed.
        logger.warning(validated.err())
        return validated

    # Set field values. This is correct because every field name that appears
    # in `new_notetype` is contained in `flatnote.fields`, or else we would
    # have printed a warning and returned above.
    # TODO: Check if these apy methods can raise exceptions.
    for key, field in flatnote.fields.items():
        if flatnote.markdown:
            note[key] = markdown_to_html(field)
        else:
            note[key] = plain_to_html(field)

    # Flush fields to collection object.
    note.flush()

    # Remove if unhealthy.
    health = display_fields_health_warning(note)
    if health != 0:
        note.col.remove_notes([note.id])
        return Err(UnhealthyNoteWarning(str(note.id)))

    return Ok(note)</code></pre>
</details>
</dd>
<dt id="ki.validate_flatnote_fields"><code class="name flex">
<span>def <span class="ident">validate_flatnote_fields</span></span>(<span>notetype: <a title="ki.types.Notetype" href="types.html#ki.types.Notetype">Notetype</a>, flatnote: <a title="ki.transformer.FlatNote" href="transformer.html#ki.transformer.FlatNote">FlatNote</a>) ‑> Union[result.result.Ok[bool], result.result.Err[Warning]]</span>
</code></dt>
<dd>
<div class="desc"><p>Validate that the fields given in the note match the notetype.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@monadic
@beartype
def validate_flatnote_fields(
    notetype: Notetype, flatnote: FlatNote
) -&gt; Result[bool, Warning]:
    &#34;&#34;&#34;Validate that the fields given in the note match the notetype.&#34;&#34;&#34;
    # Set current notetype for collection to `model_name`.
    field_names: List[str] = [field.name for field in notetype.flds]

    # TODO: Use a more descriptive error message.
    if len(flatnote.fields.keys()) != len(field_names):
        msg = f&#34;Wrong number of fields for model {flatnote.model}!&#34;
        return Err(NoteFieldValidationWarning(msg))

    for x, y in zip(field_names, flatnote.fields.keys()):
        if x != y:
            msg = f&#34;Inconsistent field names ({x} != {y})&#34;
            return Err(NoteFieldValidationWarning(msg))
    return Ok()</code></pre>
</details>
</dd>
<dt id="ki.write_decks"><code class="name flex">
<span>def <span class="ident">write_decks</span></span>(<span>col: anki.collection.Collection, targetdir: <a title="ki.types.ExtantDir" href="types.html#ki.types.ExtantDir">ExtantDir</a>, decks: dict[str, list[<a title="ki.types.ColNote" href="types.html#ki.types.ColNote">ColNote</a>]], paths: dict[str, <a title="ki.types.ExtantFile" href="types.html#ki.types.ExtantFile">ExtantFile</a>]) ‑> Union[result.result.Ok[bool], result.result.Err[Exception]]</span>
</code></dt>
<dd>
<div class="desc"><p>There is a bug in 'write_decks()'. The sorting of deck names is done by
length, in reverse, which means we start from the deepest, most specific
decks, and end up at the root. I.e. We are traversing up a tree from the
leaves to the root. Previously (see earlier commits), we simply accumulated
all model ids and wrote the entire list (so far) to each deck's model.json
file. But this is actually wrong, because if we have two subtrees, the one
with larger height may have its model ids end up in the other. Since we're
sorting by string length, it's a very imprecise, wrong way to do things.
The proper way to do this is a DFS traversal, perhaps recursively, which
will make it easier to keep things purely functional, accumulating the
model ids of the children in each node. For this, we must construct a tree
from the deck names.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@monadic
@beartype
def write_decks(
    col: Collection,
    targetdir: ExtantDir,
    decks: Dict[str, List[ColNote]],
    paths: Dict[str, ExtantFile],
) -&gt; Result[bool, Exception]:
    &#34;&#34;&#34;
    There is a bug in &#39;write_decks()&#39;. The sorting of deck names is done by
    length, in reverse, which means we start from the deepest, most specific
    decks, and end up at the root. I.e. We are traversing up a tree from the
    leaves to the root. Previously (see earlier commits), we simply accumulated
    all model ids and wrote the entire list (so far) to each deck&#39;s model.json
    file. But this is actually wrong, because if we have two subtrees, the one
    with larger height may have its model ids end up in the other. Since we&#39;re
    sorting by string length, it&#39;s a very imprecise, wrong way to do things.
    The proper way to do this is a DFS traversal, perhaps recursively, which
    will make it easier to keep things purely functional, accumulating the
    model ids of the children in each node. For this, we must construct a tree
    from the deck names.
    &#34;&#34;&#34;
    # Accumulate pairs of model ids and notetype maps. The return type of the
    # `ModelManager.get()` call below indicates that it may return `None`,
    # but we know it will not because we are getting the notetype id straight
    # from the Anki DB.
    models_map: Dict[int, NotetypeDict] = {}
    for nt_name_id in col.models.all_names_and_ids():
        models_map[nt_name_id.id] = col.models.get(nt_name_id.id)

    # Dump the models file for the whole repository.
    with open(targetdir / MODELS_FILE, &#34;w&#34;, encoding=&#34;UTF-8&#34;) as f:
        json.dump(models_map, f, ensure_ascii=False, indent=4)

    for deck_name in sorted(set(decks.keys()), key=len, reverse=True):
        deck_dir: ExtantDir = create_deck_dir(deck_name, targetdir)
        model_ids: Set[int] = set()
        deck: List[ColNote] = decks[deck_name]
        for colnote in deck:
            model_ids.add(colnote.notetype.id)
            notepath: ExtantFile = get_note_path(colnote.sortf_text, deck_dir)
            payload: str = get_note_payload(colnote, paths)
            notepath.write_text(payload, encoding=&#34;UTF-8&#34;)

        # Write `models.json` for current deck.
        deck_models_map = {mid: models_map[mid] for mid in model_ids}
        with open(deck_dir / MODELS_FILE, &#34;w&#34;, encoding=&#34;UTF-8&#34;) as f:
            json.dump(deck_models_map, f, ensure_ascii=False, indent=4)

    return Ok()</code></pre>
</details>
</dd>
<dt id="ki.write_repository"><code class="name flex">
<span>def <span class="ident">write_repository</span></span>(<span>col_file: <a title="ki.types.ExtantFile" href="types.html#ki.types.ExtantFile">ExtantFile</a>, targetdir: <a title="ki.types.ExtantDir" href="types.html#ki.types.ExtantDir">ExtantDir</a>, leaves: <a title="ki.types.Leaves" href="types.html#ki.types.Leaves">Leaves</a>, silent: bool) ‑> Union[result.result.Ok[bool], result.result.Err[Exception]]</span>
</code></dt>
<dd>
<div class="desc"><p>Write notes to appropriate directories in <code>targetdir</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@monadic
@beartype
def write_repository(
    col_file: ExtantFile, targetdir: ExtantDir, leaves: Leaves, silent: bool
) -&gt; Result[bool, Exception]:
    &#34;&#34;&#34;Write notes to appropriate directories in `targetdir`.&#34;&#34;&#34;

    # Create config file.
    config_file: ExtantFile = leaves.files[CONFIG_FILE]
    config = configparser.ConfigParser()
    config[&#34;remote&#34;] = {&#34;path&#34;: col_file}
    with open(config_file, &#34;w&#34;, encoding=&#34;UTF-8&#34;) as config_f:
        config.write(config_f)

    # Create temp directory for htmlfield text files.
    tempdir: EmptyDir = F.mkdtemp()
    root: EmptyDir = F.mksubdir(tempdir, FIELD_HTML_SUFFIX)

    paths: Dict[str, ExtantFile] = {}
    decks: Dict[str, List[ColNote]] = {}

    # Open deck with `apy`, and dump notes and markdown files.
    cwd: ExtantDir = F.cwd()
    col = Collection(col_file)
    F.chdir(cwd)

    all_nids = list(col.find_notes(query=&#34;&#34;))
    for nid in tqdm(all_nids, ncols=TQDM_NUM_COLS, disable=silent):
        colnote: OkErr = get_colnote(col, nid)
        if colnote.is_err():
            return colnote
        colnote: ColNote = colnote.unwrap()
        decks[colnote.deck] = decks.get(colnote.deck, []) + [colnote]
        for fieldname, fieldtext in colnote.n.items():
            if re.search(HTML_REGEX, fieldtext):
                fid: str = get_field_note_id(nid, fieldname)
                html_file: ExtantFile = F.touch(root, fid)
                html_file.write_text(fieldtext, encoding=&#34;UTF-8&#34;)
                paths[fid] = html_file

    # TODO: Consider adding a block in `safe()` that looks for a token
    # keyword argument, like `_err`, and bypasses the function call if it
    # is an Err. If it is an Ok, it simply removes that key-value pair from
    # `kwargs` and calls the function as it normally would.
    tidied: OkErr = tidy_html_recursively(root, silent)
    if tidied.is_err():
        return tidied
    wrote: OkErr = write_decks(col, targetdir, decks, paths)

    # Replace with frmtree.
    shutil.rmtree(root)

    return wrote</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="ki Home" href="index.html">
<img src="u1F367-shavedice.svg" alt=""> ki
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#source-code">Source code</a></li>
<li><a href="#installation">Installation</a></li>
<li><a href="#usage-reference">Usage reference</a><ul>
<li><a href="#clone">Clone</a></li>
<li><a href="#pull">Pull</a></li>
<li><a href="#push">Push</a></li>
</ul>
</li>
<li><a href="#getting-started">Getting started</a><ul>
<li><a href="#finding-the-anki2-collection-file">Finding the .anki2 collection file</a><ul>
<li><a href="#macos">MacOS</a></li>
<li><a href="#windows">Windows</a></li>
<li><a href="#gnulinux">GNU/Linux</a></li>
<li><a href="#multiple-profiles">Multiple profiles</a></li>
</ul>
</li>
<li><a href="#running-the-clone-command">Running the clone command</a></li>
<li><a href="#editing-notes">Editing notes</a></li>
<li><a href="#pushing-committed-changes-back-to-anki">Pushing committed changes back to Anki</a></li>
<li><a href="#pulling-changes-from-anki-into-the-repository">Pulling changes from Anki into the repository</a><ul>
<li><a href="#merge-conflicts">Merge conflicts</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#collaborative-decks">Collaborative decks</a><ul>
<li><a href="#cloning-a-collaborative-deck-from-github">Cloning a collaborative deck from GitHub</a><ul>
<li><a href="#adding-the-repository-as-a-git-submodule">Adding the repository as a git submodule</a></li>
</ul>
</li>
<li><a href="#editing-a-collaborative-deck">Editing a collaborative deck</a></li>
</ul>
</li>
<li><a href="#how-it-works">How it works</a></li>
<li><a href="#model">Model</a></li>
<li><a href="#generating-html">Generating html</a><ul>
<li><a href="#example-generating-syntax-highlighted-code-blocks">Example: generating syntax-highlighted code blocks</a><ul>
<li><a href="#adding-ki-html-attributes">Adding ki HTML attributes</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="ki.functional" href="functional.html">ki.functional</a></code></li>
<li><code><a title="ki.maybes" href="maybes.html">ki.maybes</a></code></li>
<li><code><a title="ki.monadic" href="monadic.html">ki.monadic</a></code></li>
<li><code><a title="ki.transformer" href="transformer.html">ki.transformer</a></code></li>
<li><code><a title="ki.types" href="types.html">ki.types</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="ki.append_md5sum" href="#ki.append_md5sum">append_md5sum</a></code></li>
<li><code><a title="ki.backup" href="#ki.backup">backup</a></code></li>
<li><code><a title="ki.create_deck_dir" href="#ki.create_deck_dir">create_deck_dir</a></code></li>
<li><code><a title="ki.diff_repos" href="#ki.diff_repos">diff_repos</a></code></li>
<li><code><a title="ki.display_fields_health_warning" href="#ki.display_fields_health_warning">display_fields_health_warning</a></code></li>
<li><code><a title="ki.echo" href="#ki.echo">echo</a></code></li>
<li><code><a title="ki.filter_note_path" href="#ki.filter_note_path">filter_note_path</a></code></li>
<li><code><a title="ki.flatten_staging_repo" href="#ki.flatten_staging_repo">flatten_staging_repo</a></code></li>
<li><code><a title="ki.get_colnote" href="#ki.get_colnote">get_colnote</a></code></li>
<li><code><a title="ki.get_colnote_repr" href="#ki.get_colnote_repr">get_colnote_repr</a></code></li>
<li><code><a title="ki.get_ephemeral_kirepo" href="#ki.get_ephemeral_kirepo">get_ephemeral_kirepo</a></code></li>
<li><code><a title="ki.get_ephemeral_repo" href="#ki.get_ephemeral_repo">get_ephemeral_repo</a></code></li>
<li><code><a title="ki.get_field_note_id" href="#ki.get_field_note_id">get_field_note_id</a></code></li>
<li><code><a title="ki.get_header_lines" href="#ki.get_header_lines">get_header_lines</a></code></li>
<li><code><a title="ki.get_models_recursively" href="#ki.get_models_recursively">get_models_recursively</a></code></li>
<li><code><a title="ki.get_note_path" href="#ki.get_note_path">get_note_path</a></code></li>
<li><code><a title="ki.get_note_payload" href="#ki.get_note_payload">get_note_payload</a></code></li>
<li><code><a title="ki.get_target" href="#ki.get_target">get_target</a></code></li>
<li><code><a title="ki.git_subprocess_pull" href="#ki.git_subprocess_pull">git_subprocess_pull</a></code></li>
<li><code><a title="ki.html_to_screen" href="#ki.html_to_screen">html_to_screen</a></code></li>
<li><code><a title="ki.init_repos" href="#ki.init_repos">init_repos</a></code></li>
<li><code><a title="ki.is_anki_note" href="#ki.is_anki_note">is_anki_note</a></code></li>
<li><code><a title="ki.lock" href="#ki.lock">lock</a></code></li>
<li><code><a title="ki.parse_markdown_note" href="#ki.parse_markdown_note">parse_markdown_note</a></code></li>
<li><code><a title="ki.parse_notetype_dict" href="#ki.parse_notetype_dict">parse_notetype_dict</a></code></li>
<li><code><a title="ki.pull_changes_from_remote_repo" href="#ki.pull_changes_from_remote_repo">pull_changes_from_remote_repo</a></code></li>
<li><code><a title="ki.pull_theirs_from_remote" href="#ki.pull_theirs_from_remote">pull_theirs_from_remote</a></code></li>
<li><code><a title="ki.push_deltas" href="#ki.push_deltas">push_deltas</a></code></li>
<li><code><a title="ki.push_flatnote_to_anki" href="#ki.push_flatnote_to_anki">push_flatnote_to_anki</a></code></li>
<li><code><a title="ki.regenerate_note_file" href="#ki.regenerate_note_file">regenerate_note_file</a></code></li>
<li><code><a title="ki.tidy_html_recursively" href="#ki.tidy_html_recursively">tidy_html_recursively</a></code></li>
<li><code><a title="ki.unlock" href="#ki.unlock">unlock</a></code></li>
<li><code><a title="ki.unsubmodule_repo" href="#ki.unsubmodule_repo">unsubmodule_repo</a></code></li>
<li><code><a title="ki.update_note" href="#ki.update_note">update_note</a></code></li>
<li><code><a title="ki.validate_flatnote_fields" href="#ki.validate_flatnote_fields">validate_flatnote_fields</a></code></li>
<li><code><a title="ki.write_decks" href="#ki.write_decks">write_decks</a></code></li>
<li><code><a title="ki.write_repository" href="#ki.write_repository">write_repository</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>