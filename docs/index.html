<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ki API documentation</title>
<meta name="description" content="Python package `ki` is a command-line interface for the version control and
editing of ``.anki2`` collections as git repositories of markdown files.
…" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:20%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
<link rel="canonical" href="ki/">
<link rel="icon" href="u1F367-shavedice.svg">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>ki</code></h1>
</header>
<section id="section-intro">
<p>Python package <code><a title="ki" href="#ki">ki</a></code> is a command-line interface for the version control and
editing of <code>.anki2</code> collections as git repositories of markdown files.
Rather than providing an interactive UI like the Anki desktop client, <code><a title="ki" href="#ki">ki</a></code> aims
to allow natural editing <em>in the filesystem</em>.</p>
<p>In general, the purpose of <code><a title="ki" href="#ki">ki</a></code> is to allow users to work on large, complex
Anki decks in exactly the same way they work on large, complex software
projects.</p>
<p><code><a title="ki" href="#ki">ki</a></code> provides command-line functions to:</p>
<ol>
<li><strong>clone</strong> a <code>.anki2</code> collection into a directory as a git repository,</li>
<li><strong>pull</strong> changes from the Anki desktop client (and AnkiWeb) into an existing
repository,</li>
<li><strong>push</strong> changes (safely!) back to Anki.</li>
</ol>
<blockquote>
<p><strong>INTERNAL.</strong> Perhaps we should support making each deck a separate git
submodule, so that users can have collaborative decks and work on them within
their own collections.</p>
</blockquote>
<h1 id="installation">Installation</h1>
<p><code><a title="ki" href="#ki">ki</a></code> is tested on Python 3.9 and Anki 2.1.49.</p>
<ol>
<li>Install the <code><a title="ki" href="#ki">ki</a></code> package from PyPI:</li>
</ol>
<pre><code class="language-bash">pip install anki-ki
</code></pre>
<h1 id="usage">Usage</h1>
<h2 id="cloning-an-anki-collection-into-a-new-ki-repository">Cloning an Anki collection into a new <code><a title="ki" href="#ki">ki</a></code> repository</h2>
<p>The <code><a title="ki" href="#ki">ki</a> clone</code> command takes one required argument (the path to a <code>.anki2</code>
file) and one optional argument (a path to a target directory). The usage is
meant to mirror that of <code>git clone</code>.</p>
<p>An example of the <code>clone</code> subcommand usage and its output is given below.</p>
<pre><code class="language-bash">$ ki clone ~/.local/share/Anki2/lyra/collection.anki2 decks
</code></pre>
<pre><code class="language-bash">Found .anki2 file at '/home/lyra/.local/share/Anki2/lyra/collection.anki2'
Computed md5sum: ad7ea6d486a327042cf0b09b54626b66
Wrote md5sum to '/home/lyra/decks/.ki/hashes'
Cloning into '/home/lyra/decks/'...
100%|█████████████████████████| 28886/28886 [00:10&lt;00:00, 2883.78it/s]
</code></pre>
<h2 id="pulling-changes-from-an-anki-collection-into-an-existing-ki-repository">Pulling changes from an Anki collection into an existing <code><a title="ki" href="#ki">ki</a></code> repository</h2>
<p>Once an Anki collection has been cloned, we can <code>pull</code> changes made by the Anki
desktop client into our repository.</p>
<p>An example of the <code>pull</code> subcommand usage and its output is given below.</p>
<pre><code class="language-bash">$ ki pull
</code></pre>
<pre><code class="language-bash">Pulling from '/home/lyra/.local/share/Anki2/lyra/collection.anki2'
Computed md5sum: 199216c39eeabe23a1da016a99ffd3e2
Updating 5a9ef09..9c30b73
Fast-forward
 note1645010162168.md |  4 ++--
 note1645222430007.md | 11 +++++++++++
 2 files changed, 13 insertions(+), 2 deletions(-)
 create mode 100644 note1645222430007.md

From /tmp/tmpt5a3yd9a/ki/local/199216c39eeabe23a1da016a99ffd3e2/
 * branch            main       -&gt; FETCH_HEAD
 * [new branch]      main       -&gt; anki/main

Wrote md5sum to '/home/lyra/decks/.ki/hashes'
</code></pre>
<p><code><a title="ki" href="#ki">ki</a></code> first deletes any residual ephemeral repositories in <code>/tmp/ki/remote/</code>.
These would only remain here if a previous pull command failed.</p>
<p>It then verifies that the path to the <code>.anki2</code> file specified in the <code>.ki/</code>
directory (analogous to the <code>.git/</code> directory) still exists.</p>
<p>It computes and records the hash of the collection file. In this way, <code><a title="ki" href="#ki">ki</a></code>
keeps track of whether the collection database has changed since the last
<code>clone</code>/<code>pull</code>.</p>
<p>Finally, the collection is then cloned into an ephemeral repository in a temp
directory, which is then <code>git pull</code>-ed into the current repository.</p>
<p>At this point, if the git operation fails, the user can take over and manage
the merge themselves.</p>
<h2 id="pushing-changes-in-a-ki-repository-to-an-anki-collection">Pushing changes in a <code><a title="ki" href="#ki">ki</a></code> repository to an Anki collection</h2>
<p>When we want to push our changes back to the Anki desktop client, we can use
<code><a title="ki" href="#ki">ki</a> push</code> to do that.</p>
<p>An example of the <code>push</code> subcommand usage and its output is given below.</p>
<pre><code class="language-bash">$ ki push
</code></pre>
<pre><code class="language-bash">Pushing to '/home/lyra/.local/share/Anki2/lyra/collection.anki2'
Computed md5sum: 199216c39eeabe23a1da016a99ffd3e2
Verified md5sum matches latest hash in '/home/lyra/decks/.ki/hashes'
Generating local .anki2 file from latest commit: 2aa009729b6dd337dd1ce795df611f5a49f35787
Writing changes to '/tmp/tmpyiids2qm/original.anki2'...
100%|█████████████████████████████████| 2/2 [00:00&lt;00:00, 1081.56it/s]
Database was modified.
Writing backup of .anki2 file to '/home/lyra/decks/.ki/backups'
Overwrote '/home/lyra/.local/share/Anki2/lyra/collection.anki2'
</code></pre>
<p>We store 5 backups of the collection prior to a push.</p>
<blockquote>
<p><strong>INTERNAL</strong>. It is not necessary to have a persistent "remote" copy of the
repo to pull from. The remote can be ephemeral. It only exists when we <code><a title="ki" href="#ki">ki</a> pull</code>,
and then <code><a title="ki" href="#ki">ki</a></code> deletes it. This is safe because we're checking the
<code>md5sum</code> of <code>collection.anki2</code>. Notably, it is not created when we <code><a title="ki" href="#ki">ki</a> clone</code>
or <code><a title="ki" href="#ki">ki</a> push</code>.</p>
</blockquote>
<h1 id="editing-notes">Editing notes</h1>
<p>An example of a generated markdown note is given below:</p>
<pre><code class="language-markdown"># Note
nid: 1636122987400
model: Basic
deck: Decks::Mathematics::Differentiable Manifolds
tags:
markdown: false

## Front
What sort of object is `\(C_0(X)\)`?

## Back
A Banach algebra, and more specifically a `\(C^*\)`-algebra
</code></pre>
<h1 id="how-it-works">How it works</h1>
<p><code><a title="ki" href="#ki">ki</a></code> is built on top of existing tooling implemented in the python package
<a href="https://github.com/lervag/apy"><code>apy</code></a>, which is used to parse the Anki
collection SQLite file and convert its contents to human-readable markdown
files.</p>
<p>These files (one per Anki note) are then dumped to a configurable location in
the filesystem as a git repository, whose structure mirrors that of the decks
in the collection. In effect, <code><a title="ki" href="#ki">ki</a></code> treats the git repo it generates as a local
copy of the collection, and the <code>.anki2</code> collection file as a remote.</p>
<p>All operations like pulling updates to the collection into <code><a title="ki" href="#ki">ki</a></code> and pushing
updates from <code><a title="ki" href="#ki">ki</a></code> into Anki are handled by git under the hood.</p>
<p>This appproach has several advantages:</p>
<ol>
<li>Merge conflicts can be handled in the usual, familiar way.</li>
<li>Additional remotes (e.g. a human-readable backup of a collection on github)
can be added easily.</li>
<li>Users are free to pick the editor of their choice, perform batch editing
with command line tools like <code>awk</code> or <code>sed</code>, and even add CI actions.</li>
</ol>
<h1 id="model">Model</h1>
<p>The following diagram shows the dataflow of a typical Anki/<code><a title="ki" href="#ki">ki</a></code> stack.</p>
<pre><code>                 +-------------+          +--------------+
                 |             |          |              |
                 |   AnkiWeb  -------------  AnkiMobile  |
                 |             |   sync   |              |
                 +------|------+          +--------------+
                        |
                        | sync
                        |
                 +------|------+
                 |             |
                 |    Anki     |
                 |             |
                 +------|------+
                        |
                        | deck edits
                        |
               +--------|--------+               +------------------+
               |                 |    ki clone   |                  |
               |                 ----------------&gt;                  |
               | Collection file |               |     ~/decks/     |
               |    (.anki2)     |    ki push    | (git repository) |
               |                 &lt;----------------                  |
               |                 |               |                  |
               +--------|--------+               +---------^--------+
                        |                                  |
                        | ki pull                          |
                        |                                  |
                        |                                  |
             +----------v----------+                       |
             |                     |                       |
             | /tmp/ki/remote/AAA  |           ki pull     |
             |  (git repository)   -------------------------
             |    [ephemeral]      |
             |                     |
             +---------------------+
</code></pre>
<p>The node labeled Anki is the Anki desktop client on the localhost. It
communicates with the AnkiWeb servers via Anki's sync feature. Other clients
(e.g. AnkiDroid and AnkiMobile) are able to (1) pull changes made by the
desktop client into their local collections via AnkiWeb, and (2) push changes
made locally back to AnkiWeb.</p>
<p>When the Anki desktop client is started on the localhost, it opens and places a
lock on the <code>.anki2</code> SQLite file. During the session, changes are possibly made
to the deck, and the SQLite file is unlocked when the program is closed.</p>
<p>Since <code><a title="ki" href="#ki">ki</a></code> must read from this database file, that means that <code><a title="ki" href="#ki">ki</a></code> commands
will not work while Anki is running. This is <strong>by design</strong>: the database is
locked for a reason, and enforcing this constraint lowers the likelihood that
users' decks become corrupted.</p>
<p>An ephemeral repository is used as an auxiliary step during the <code><a title="ki" href="#ki">ki</a> pull</code>
operation so that we can merge the Anki desktop client's changes into our
repository via git.</p>
<h1 id="generating-html">Generating html</h1>
<p>By default, <code><a title="ki" href="#ki">ki</a></code> parses the html of each field and dumps the content only,
insofar as that is possible. It also supports parsing arbitrary html elements
autogenerated by addons and regenerated the updated content. In the following
subsection, we walk through an example.</p>
<h2 id="example-generating-syntax-highlighted-code-blocks">Example: generating syntax-highlighted code blocks</h2>
<p>The anki addon developer Glutanimate has an addon called <code>syntax-highlighting</code>,
which adds UI elements to the Anki note editor that automatically generates a
syntax highlighted version of a code block from the clipboard. In effect, it
generates a formatted HTML table for the code listing that gets dumped into the
source of relevant note field.</p>
<p>A fork of this addon for the latest version of Anki (2.1.49 at the time of
writing), is available here:
<a href="https://ankiweb.net/shared/info/1972239816">https://ankiweb.net/shared/info/1972239816</a></p>
<p>And the source tree for the original addon is on github:
<a href="https://github.com/glutanimate/syntax-highlighting">https://github.com/glutanimate/syntax-highlighting</a></p>
<p>For example, consider the following python code block:</p>
<pre><code class="language-python">n = 1
n &gt;&gt; 1
print(n)
</code></pre>
<p>Given the above code, the addon generates the following HTML:</p>
<pre><code class="language-html">&lt;table class=&quot;highlighttable&quot;&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;td class=&quot;linenos&quot;&gt;
                &lt;div class=&quot;linenodiv&quot;&gt;
                    &lt;pre&gt;
                        &lt;span class=&quot;normal&quot;&gt;1&lt;/span&gt;
                        &lt;span class=&quot;normal&quot;&gt;2&lt;/span&gt;
                        &lt;span class=&quot;normal&quot;&gt;3&lt;/span&gt;
                    &lt;/pre&gt;
                &lt;/div&gt;
            &lt;/td&gt;
            &lt;td class=&quot;code&quot;&gt;
                &lt;div class=&quot;highlight&quot;&gt;
                    &lt;pre&gt;
                        &lt;code&gt;
                            &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;
                            &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
                            &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
                            &lt;br&gt;
                                &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;
                                &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;
                                &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
                                &lt;br&gt;
                                    &lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;
                                    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
                                    &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;
                                    &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                                    &lt;br&gt;
                                    &lt;/code&gt;
                                &lt;/pre&gt;
                &lt;/div&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;
</code></pre>
<p>Editing fields like this could become annoying very quickly. It would be better
if <code><a title="ki" href="#ki">ki</a></code> just gave us the markdown version above (only 3 lines), and then
regenerated the note field HTML when converting the repository back into a
<code>.anki2</code> deck.</p>
<h3 id="adding-ki-html-attributes">Adding <code><a title="ki" href="#ki">ki</a></code> HTML attributes</h3>
<p>And in fact, this is possible. We first fork the addon so we can add some extra
data to our generated HTML. In particular, we'd like to add an attribute
<code>ki-src</code> whose value is the UTF-8 encoded source code. In general, this will be
the encoded version of the source of whatever you'd like to autoformat.</p>
<p>We also add a <code>ki-formatter</code> attribute, whose value is an identifier that
specifies a custom python module (we must implement this) that transforms the
(possibly edited) <code>ki-src</code> text back into a HTML element of the form seen
above.</p>
<p>So let's call our <code>ki-formatter</code> identifier <code>syntax-hl-python</code>. Then our addon
has to change the opening tag of the snippet above to look like:</p>
<pre><code class="language-html">&lt;table class=&quot;highlighttable&quot;; ki-src=&quot;n = 1\nn &gt;&gt; 1\nprint(n)\n&quot;; ki-formatter=&quot;syntax-hl-python&quot;&gt;
</code></pre>
<p>All <code><a title="ki" href="#ki">ki</a></code> needs is the original text of the code block prior to html formatting,
and a function that can reapply the formatting to the modified text. Since the
html table was generated by an addon, we already have a python function for
this, and in general you can provide a <code>~/.config/ki/ki.json</code> file that maps
implementation IDs to paths of python modules. The module must have a top-level
function defined of the form <code>format(text: str) -&gt; bs4.Tag</code>. If you have an
addon implementation, you can import it here and use it in your <code>format()</code>
implementation. you can add a <code><a title="ki" href="#ki">ki</a></code> attribute whose value is the base64 encoding
of the code block, and a <code>implementation</code> attribute whose value is the name of
a function. At import-time, <code><a title="ki" href="#ki">ki</a></code> will decode this and write the human-readable
source to the relevant markdown file instead.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
&#34;&#34;&#34;
Python package `ki` is a command-line interface for the version control and
editing of ``.anki2`` collections as git repositories of markdown files.
Rather than providing an interactive UI like the Anki desktop client, `ki` aims
to allow natural editing *in the filesystem*.

In general, the purpose of `ki` is to allow users to work on large, complex
Anki decks in exactly the same way they work on large, complex software
projects.
.. include:: ./DOCUMENTATION.md
&#34;&#34;&#34;

# pylint:disable=unnecessary-pass, too-many-lines

__author__ = &#34;&#34;
__email__ = &#34;&#34;
__license__ = &#34;AGPLv3&#34;
__url__ = &#34;&#34;
__version__ = &#34;0.0.1a&#34;

import os
import re
import pprint
import shutil
import logging
import tarfile
import hashlib
import sqlite3
import tempfile
import warnings
import subprocess
import configparser

import git
import anki
import click
import gitdb
from bs4 import MarkupResemblesLocatorWarning
from tqdm import tqdm
from loguru import logger

from apy.anki import Anki, Note
from apy.convert import markdown_to_html, plain_to_html, markdown_file_to_notes

from beartype import beartype
from beartype.typing import List, Dict, Any, Iterator, Sequence, Iterable, Optional

from ki.note import KiNote


logging.basicConfig(level=logging.INFO)


TQDM_NUM_COLS = 70
CHANGE_TYPES = &#34;A D R M T&#34;.split()
REMOTE_NAME = &#34;anki&#34;
HINT = (
    &#34;hint: Updates were rejected because the tip of your current branch is behind\n&#34;
    + &#34;hint: the Anki remote collection. Integrate the remote changes (e.g.\n&#34;
    + &#34;hint: &#39;ki pull ...&#39;) before pushing again.&#34;
)


# pylint: disable=invalid-name
@click.group()
@click.version_option()
@beartype
def ki() -&gt; None:
    &#34;&#34;&#34;
    The universal CLI entry point for `ki`.

    Takes no arguments, only has three subcommands (clone, pull, push).
    &#34;&#34;&#34;
    return


@ki.command()
@click.argument(&#34;collection&#34;)
@click.argument(&#34;directory&#34;, required=False, default=&#34;&#34;)
def clone(collection: str, directory: str = &#34;&#34;) -&gt; None:
    &#34;&#34;&#34;
    Clone an Anki collection into a directory.

    Parameters
    ----------
    collection : str
        The path to a `.anki2` collection file.
    directory : str, default=&#34;&#34;
        An optional path to a directory to clone the collection into.
        Note: we check that this directory does not yet exist.
    &#34;&#34;&#34;
    warnings.filterwarnings(action=&#34;ignore&#34;, category=MarkupResemblesLocatorWarning)
    repo = _clone(collection, directory, msg=&#34;Initial commit&#34;, silent=False)
    update_last_push_commit_sha(repo)


@beartype
def _clone(collection: str, directory: str, msg: str, silent: bool) -&gt; git.Repo:
    &#34;&#34;&#34;
    Clone an Anki collection into a directory.

    Parameters
    ----------
    collection : str
        The path to a `.anki2` collection file.
    directory : str
        A path to a directory to clone the collection into.
        Note: we check that this directory does not yet exist.
    msg : str
        Message for initial commit.
    silent : bool
        Indicates whether we are calling `_clone()` from `pull()`.

    Returns
    -------
    git.Repo
        The cloned repository.
    &#34;&#34;&#34;
    collection = os.path.abspath(collection)
    if not os.path.isfile(collection):
        raise FileNotFoundError
    echo(f&#34;Found .anki2 file at &#39;{collection}&#39;&#34;, silent=silent)

    # Create default target directory.
    if directory == &#34;&#34;:
        directory = get_default_clone_directory(collection)
    os.mkdir(directory)

    # Create .ki subdirectory.
    kidir = os.path.join(directory, &#34;.ki/&#34;)
    os.mkdir(kidir)

    # Create config file.
    config_path = os.path.join(kidir, &#34;config&#34;)
    config = configparser.ConfigParser()
    config[&#34;remote&#34;] = {&#34;path&#34;: collection}
    with open(config_path, &#34;w&#34;, encoding=&#34;UTF-8&#34;) as config_file:
        config.write(config_file)

    # Append to hashes file.
    md5sum = md5(collection)
    echo(f&#34;Computed md5sum: {md5sum}&#34;, silent)
    append_md5sum(kidir, collection, md5sum, silent)
    echo(f&#34;Cloning into &#39;{directory}&#39;...&#34;, silent=silent)

    # Add `.ki/` to gitignore.
    ignore_path = os.path.join(directory, &#34;.gitignore&#34;)
    with open(ignore_path, &#34;w&#34;, encoding=&#34;UTF-8&#34;) as ignore_file:
        ignore_file.write(&#34;.ki/\n&#34;)

    # Open deck with `apy`, and dump notes and markdown files.
    query = &#34;&#34;
    with Anki(path=collection) as a:
        nids = list(a.col.find_notes(query))
        for i in tqdm(nids, ncols=TQDM_NUM_COLS, disable=silent):

            # TODO: Support multiple notes per-file.
            note = KiNote(a, a.col.getNote(i))
            note_path = os.path.join(directory, f&#34;note{note.n.id}.md&#34;)
            with open(note_path, &#34;w&#34;, encoding=&#34;UTF-8&#34;) as note_file:
                note_file.write(str(note))

    # Initialize git repo and commit contents.
    repo = git.Repo.init(directory)
    repo.git.add(all=True)
    _ = repo.index.commit(msg)

    return repo


@ki.command()
@beartype
def pull() -&gt; None:
    &#34;&#34;&#34;
    Pull from a preconfigured remote Anki collection into an existing ki
    repository.
    &#34;&#34;&#34;
    # Suppress `bs4` warnings.
    warnings.filterwarnings(action=&#34;ignore&#34;, category=MarkupResemblesLocatorWarning)

    # Lock DB and get hash.
    collection = open_repo()
    con = lock(collection)
    md5sum = md5(collection)

    # Quit if hash matches last pull.
    if md5sum in get_latest_collection_hash():
        click.secho(&#34;ki pull: up to date.&#34;, bold=True)
        unlock(con)
        return

    echo(f&#34;Pulling from &#39;{collection}&#39;&#34;)
    echo(f&#34;Computed md5sum: {md5sum}&#34;)

    # Git clone `repo` at commit SHA of last successful `push()`.
    cwd = os.getcwd()
    repo = git.Repo(cwd)
    last_push_sha = get_last_push_sha(repo)
    last_push_repo = get_ephemeral_repo(&#34;ki/local/&#34;, repo, md5sum, last_push_sha)

    # Ki clone collection into an ephemeral ki repository at `anki_remote_dir`.
    msg = f&#34;Fetch changes from DB at &#39;{collection}&#39; with md5sum &#39;{md5sum}&#39;&#34;
    root = os.path.join(tempfile.mkdtemp(), &#34;ki/&#34;, &#34;remote/&#34;)
    os.makedirs(root)
    anki_remote_dir = os.path.join(root, md5sum)
    _clone(collection, anki_remote_dir, msg, silent=True)

    # Create git remote pointing to anki remote repo.
    anki_remote_path = os.path.join(anki_remote_dir, &#34;.git&#34;)
    anki_remote = last_push_repo.create_remote(REMOTE_NAME, anki_remote_path)

    # Pull anki remote repo into ``last_push_repo``.
    os.chdir(last_push_repo.working_dir)
    last_push_repo.git.config(&#34;pull.rebase&#34;, &#34;false&#34;)
    p = subprocess.run(
        [
            &#34;git&#34;,
            &#34;pull&#34;,
            &#34;-v&#34;,
            &#34;--allow-unrelated-histories&#34;,
            &#34;--strategy-option&#34;,
            &#34;theirs&#34;,
            REMOTE_NAME,
            &#34;main&#34;,
        ],
        check=True,
        capture_output=True,
    )
    last_push_repo.delete_remote(anki_remote)

    # Create remote pointing to ``last_push`` repo and pull into ``repo``.
    os.chdir(cwd)
    last_push_remote_path = os.path.join(last_push_repo.working_dir, &#34;.git&#34;)
    last_push_remote = repo.create_remote(REMOTE_NAME, last_push_remote_path)
    repo.git.config(&#34;pull.rebase&#34;, &#34;false&#34;)
    p = subprocess.run(
        [&#34;git&#34;, &#34;pull&#34;, &#34;-v&#34;, REMOTE_NAME, &#34;main&#34;],
        check=False,
        capture_output=True,
    )
    click.secho(f&#34;{p.stdout.decode()}&#34;, bold=True)
    click.secho(f&#34;{p.stderr.decode()}&#34;, bold=True)
    repo.delete_remote(last_push_remote)

    # Append to hashes file.
    append_md5sum(os.path.join(cwd, &#34;.ki&#34;), collection, md5sum)

    # Check that md5sum hasn&#39;t changed.
    assert md5(collection) == md5sum
    unlock(con)


@ki.command()
@beartype
def push() -&gt; None:
    &#34;&#34;&#34;
    Pack a ki repository into a .anki2 file and push to collection location.

    1. Clone the repository at the latest commit in a staging repo.
    2. Get all notes that have changed since the last successful push.
    3. Clone repository at SHA of last successful push to get nids of deleted files.
    4. Add/edit/delete notes using `apy`.
    &#34;&#34;&#34;
    # Lock DB, get path to collection, and compute hash.
    collection = open_repo()
    con = lock(collection)
    md5sum = md5(collection)

    # Quit if hash doesn&#39;t match last pull.
    if md5sum not in get_latest_collection_hash():
        failed: str = f&#34;Failed to push some refs to &#39;{collection}&#39;\n{HINT}&#34;
        click.secho(failed, fg=&#34;yellow&#34;, bold=True)
        unlock(con)
        return

    # Clone latest commit into a staging repo.
    cwd = os.getcwd()
    repo = git.Repo(cwd)
    sha = str(repo.head.commit)
    staging_repo = get_ephemeral_repo(&#34;ki/local/&#34;, repo, md5sum, sha)

    # Copy `.ki/` directory into the staging repo.
    repo_kidir = os.path.join(cwd, &#34;.ki/&#34;)
    staging_repo_kidir = os.path.join(staging_repo.working_dir, &#34;.ki/&#34;)
    shutil.copytree(repo_kidir, staging_repo_kidir)

    # Get all notes changed between LAST_PUSH and HEAD.
    notepaths: Iterator[str] = get_note_files_changed_since_last_push(staging_repo)

    # If there are no changes, update LAST_PUSH commit and quit.
    if len(set(notepaths)) == 0:
        click.secho(&#34;ki push: up to date.&#34;, bold=True)
        update_last_push_commit_sha(repo)
        return

    hashes_path = os.path.join(repo_kidir, &#39;hashes&#39;)
    echo(f&#34;Pushing to &#39;{collection}&#39;&#34;)
    echo(f&#34;Computed md5sum: {md5sum}&#34;)
    echo(f&#34;Verified md5sum matches latest hash in &#39;{hashes_path}&#39;&#34;)

    # Copy collection to a temp directory.
    new_collection = os.path.join(tempfile.mkdtemp(), os.path.basename(collection))
    assert not os.path.isfile(new_collection)
    assert not os.path.isdir(new_collection)
    shutil.copyfile(collection, new_collection)
    echo(f&#34;Generating local .anki2 file from latest commit: {sha}&#34;)
    echo(f&#34;Writing changes to &#39;{new_collection}&#39;...&#34;)

    # Edit the copy with `apy`.
    with Anki(path=new_collection) as a:

        # DEBUG
        nids = list(a.col.find_notes(&#34;&#34;))

        # Clone repository state at commit SHA of LAST_PUSH to parse deleted notes.
        last_push_sha = get_last_push_sha(staging_repo)
        deletions_repo = get_ephemeral_repo(&#34;ki/deleted/&#34;, repo, md5sum, last_push_sha)

        # Gather logging statements to display.
        log: List[str] = []

        new_nid_path_map = {}

        p = subprocess.run([&#34;git&#34;, &#34;rev-parse&#34;, &#34;-q&#34;, &#34;--verify&#34;, &#34;refs/stash&#34;], check=False, capture_output=True)
        stash_ref = p.stdout.decode()

        # Stash both unstaged and staged files (including untracked).
        repo.git.stash(include_untracked=True, keep_index=True)
        repo.git.reset(&#34;HEAD&#34;, hard=True)

        # TODO: All this logic can be abstracted away from the process of
        # actually parsing notes and constructing Anki-specific objects. This
        # is just a series of filesystem ops. They should be put in a
        # standalone function and tested without anything related to Anki.
        for notepath in tqdm(notepaths, ncols=TQDM_NUM_COLS):

            # If the file doesn&#39;t exist, parse its `nid` from its counterpart
            # in `deletions_repo`, and then delete using `apy`.
            if not os.path.isfile(notepath):
                deleted_file = os.path.basename(notepath)
                deleted_path = os.path.join(deletions_repo.working_dir, deleted_file)

                assert os.path.isfile(deleted_path)
                nids = get_nids(deleted_path)
                delete_notes(a, nids)
                continue

            # Track whether Anki reassigned any nids.
            reassigned = False
            notes: List[KiNote] = []
            new_nids = set()

            # Loop over nids and edit/add/delete notes.
            for notemap in parse_markdown_notes(notepath):
                nid = notemap[&#34;nid&#34;]
                try:
                    note: KiNote = KiNote(a, a.col.get_note(nid))
                    update_apy_note(note, notemap)
                    notes.append(note)
                except anki.errors.NotFoundError:
                    note: KiNote = add_note_from_notemap(a, notemap)
                    log.append(f&#34;Couldn&#39;t find note with nid: &#39;{nid}&#39;&#34;)
                    log.append(f&#34;Assigned new nid: &#39;{note.n.id}&#39;&#34;)
                    new_nids.add(note.n.id)
                    notes.append(note)
                    reassigned = True

            # If we reassigned any nids, we must regenerate the whole file.
            if reassigned:
                assert len(notes) &gt; 0
                if len(notes) &gt; 1:
                    logger.warning(&#34;MULTIPLE NOTES IN A SINGLE FILE!&#34;)

                # Get paths to note in local repo, as distinct from staging repo.
                note_relpath = os.path.relpath(notepath, staging_repo.working_dir)
                repo_notepath = os.path.join(repo.working_dir, note_relpath)

                # If this is not an entirely new file, remove it.
                if os.path.isfile(repo_notepath):
                    os.remove(repo_notepath)

                # Construct markdown file contents and write.
                content: str = &#34;&#34;
                for note in notes:
                    content += f&#34;{str(note)}\n\n&#34;
                first_nid = notes[0].n.id
                parent = os.path.abspath(os.path.join(repo_notepath, os.pardir))
                new_notepath = os.path.join(parent, f&#34;note{first_nid}.md&#34;)
                with open(new_notepath, &#34;w&#34;, encoding=&#34;UTF-8&#34;) as note_file:
                    note_file.write(content)
                for nid in new_nids:
                    new_note_relpath = os.path.relpath(new_notepath, repo.working_dir)
                    new_nid_path_map[nid] = new_note_relpath

        if len(new_nid_path_map) &gt; 0:
            msg = &#34;Generated new nid(s).\n\n&#34;
            for new_nid, path in new_nid_path_map.items():
                msg += f&#34;Wrote new &#39;{new_nid}&#39; in file {path}\n&#34;
            repo.git.add(all=True)
            _ = repo.index.commit(msg)

        p = subprocess.run([&#34;git&#34;, &#34;rev-parse&#34;, &#34;-q&#34;, &#34;--verify&#34;, &#34;refs/stash&#34;], check=False, capture_output=True)
        new_stash_ref = p.stdout.decode()

        # Display warnings.
        for line in log:
            click.secho(line, bold=True, fg=&#34;yellow&#34;)

        # DEBUG
        nids = list(a.col.find_notes(&#34;&#34;))

    assert os.path.isfile(new_collection)

    # Backup collection file and overwrite collection.
    backup(collection)
    shutil.copyfile(new_collection, collection)
    echo(f&#34;Overwrote &#39;{collection}&#39;&#34;)

    # Append to hashes file.
    new_md5sum = md5(new_collection)
    append_md5sum(os.path.join(cwd, &#34;.ki&#34;), new_collection, new_md5sum, silent=True)

    # Update LAST_PUSH commit SHA file and unlock DB.
    update_last_push_commit_sha(repo)
    unlock(con)


# UTILS


@beartype
def delete_notes(apyanki: Anki, ids: Sequence[int]) -&gt; None:
    &#34;&#34;&#34;Delete notes by note ids&#34;&#34;&#34;
    if not isinstance(ids, list):
        ids = [ids]

    op_changes = apyanki.col.remove_notes(ids)
    apyanki.modified = True


@beartype
def parse_markdown_notes(path: str) -&gt; List[Dict[str, Any]]:
    &#34;&#34;&#34;Parse nids from markdown file of notes.&#34;&#34;&#34;
    # Support multiple notes-per-file.
    notemaps: List[Dict[str, Any]] = markdown_file_to_notes(path)
    casted_notemaps = []
    for notemap in notemaps:
        try:
            nid = int(notemap[&#34;nid&#34;])
            notemap[&#34;nid&#34;] = nid
            casted_notemaps.append(notemap)
        except KeyError as err:
            logger.error(&#34;Failed to parse nid.&#34;)
            logger.error(f&#34;notemap: {notemap}&#34;)
            logger.error(f&#34;path: {path}&#34;)
            raise err
    return casted_notemaps


@beartype
def get_nids(path: str) -&gt; List[int]:
    &#34;&#34;&#34;Get just nids from a markdown note.&#34;&#34;&#34;
    notemaps = parse_markdown_notes(path)
    return [notemap[&#34;nid&#34;] for notemap in notemaps]


@beartype
def get_default_clone_directory(collection_path: str) -&gt; str:
    &#34;&#34;&#34; &#34;
    Get the default clone directory path.

    This should just be the name of the collection (which is usually a file
    called `collection.anki2`) so this will usually be `./collection/`.

    Parameters
    ----------
    collection_path : str
        The path to a `.anki2` collection file.

    Returns
    -------
    str
        The path to clone into.
    &#34;&#34;&#34;
    basename = os.path.basename(collection_path)
    sections = os.path.splitext(basename)
    assert len(sections) == 2
    return os.path.abspath(sections[0])


@beartype
def md5(path: str) -&gt; str:
    &#34;&#34;&#34;Compute md5sum of file at `path`.&#34;&#34;&#34;
    hash_md5 = hashlib.md5()
    with open(path, &#34;rb&#34;) as f:
        for chunk in iter(lambda: f.read(4096), b&#34;&#34;):
            hash_md5.update(chunk)
    return hash_md5.hexdigest()


@beartype
def is_anki_note(path: str) -&gt; bool:
    &#34;&#34;&#34;Check if file is an `apy`-style markdown anki note.&#34;&#34;&#34;
    # Ought to have markdown file extension.
    if path[-3:] != &#34;.md&#34;:
        return False
    with open(path, &#34;r&#34;, encoding=&#34;UTF-8&#34;) as md_file:
        lines = md_file.readlines()
    if len(lines) &lt; 2:
        return False
    if lines[0] != &#34;# Note\n&#34;:
        return False
    if not re.match(r&#34;^nid: [0-9]+$&#34;, lines[1]):
        return False
    return True


@beartype
def update_apy_note(note: KiNote, notemap: Dict[str, Any]) -&gt; None:
    &#34;&#34;&#34;Update an `apy` Note in a collection.&#34;&#34;&#34;
    new_tags = notemap[&#34;tags&#34;].split()
    if new_tags != note.n.tags:
        note.n.tags = new_tags

    new_deck = notemap.get(&#34;deck&#34;, None)
    if new_deck is not None and new_deck != note.get_deck():
        note.set_deck(new_deck)

    for i, value in enumerate(notemap[&#34;fields&#34;].values()):
        if notemap[&#34;markdown&#34;]:
            note.n.fields[i] = markdown_to_html(value)
        else:
            note.n.fields[i] = plain_to_html(value)

    note.n.flush()
    note.a.modified = True
    fields_health_check = note.n.fields_check()

    if fields_health_check == 1:
        logger.warning(f&#34;Found empty note:\n {note}&#34;)
        return
    if fields_health_check == 2:
        logger.warning(f&#34;Found duplicate note:\n {note}&#34;)
        return

    if fields_health_check:
        logger.warning(f&#34;Found duplicate or empty note:\n {note}&#34;)
        logger.warning(f&#34;Fields health check: {fields_health_check}&#34;)
        logger.warning(f&#34;Fields health check (type): {type(fields_health_check)}&#34;)


@beartype
def open_repo() -&gt; str:
    &#34;&#34;&#34;Get collection path from `.ki/` directory.&#34;&#34;&#34;
    # Check that config file exists.
    config_path = os.path.join(os.getcwd(), &#34;.ki/&#34;, &#34;config&#34;)
    if not os.path.isfile(config_path):
        raise FileNotFoundError

    # Parse config file.
    config = configparser.ConfigParser()
    config.read(config_path)
    collection = config[&#34;remote&#34;][&#34;path&#34;]

    if not os.path.isfile(collection):
        raise FileNotFoundError

    return collection


@beartype
def get_latest_collection_hash() -&gt; str:
    &#34;&#34;&#34;Get the last collection hash stored in `.ki/hashes`.&#34;&#34;&#34;
    kidir = os.path.join(os.getcwd(), &#34;.ki/&#34;)
    hashes_path = os.path.join(kidir, &#34;hashes&#34;)
    with open(hashes_path, &#34;r&#34;, encoding=&#34;UTF-8&#34;) as hashes_file:
        return hashes_file.readlines()[-1]


@beartype
def backup(collection: str) -&gt; None:
    &#34;&#34;&#34;Backup collection to `.ki/backups`.&#34;&#34;&#34;
    md5sum = md5(collection)
    backupsdir = os.path.join(os.getcwd(), &#34;.ki/&#34;, &#34;backups&#34;)
    assert not os.path.isfile(backupsdir)
    if not os.path.isdir(backupsdir):
        os.mkdir(backupsdir)
    backup_path = os.path.join(backupsdir, f&#34;{md5sum}.anki2&#34;)
    if os.path.isfile(backup_path):
        click.secho(&#34;Backup already exists.&#34;, bold=True)
        return
    assert not os.path.isfile(backup_path)
    echo(f&#34;Writing backup of .anki2 file to &#39;{backupsdir}&#39;&#34;)
    shutil.copyfile(collection, backup_path)
    assert os.path.isfile(backup_path)


@beartype
def lock(collection: str) -&gt; sqlite3.Connection:
    &#34;&#34;&#34;Acquire a lock on a SQLite3 database given a path.&#34;&#34;&#34;
    con = sqlite3.connect(collection)
    con.isolation_level = &#34;EXCLUSIVE&#34;
    con.execute(&#34;BEGIN EXCLUSIVE&#34;)
    return con


@beartype
def unlock(con: sqlite3.Connection) -&gt; None:
    &#34;&#34;&#34;Unlock a SQLite3 database.&#34;&#34;&#34;
    con.commit()
    con.close()


@beartype
def get_last_push_sha(repo: git.Repo) -&gt; str:
    &#34;&#34;&#34;Get LAST_PUSH SHA.&#34;&#34;&#34;
    last_push_path = os.path.join(repo.working_dir, &#34;.ki/&#34;, &#34;last_push&#34;)
    with open(last_push_path, &#34;r&#34;, encoding=&#34;UTF-8&#34;) as last_push_file:
        sha = last_push_file.read()
    return sha


@beartype
def get_note_files_changed_since_last_push(repo: git.Repo) -&gt; Sequence[str]:
    &#34;&#34;&#34;Gets a list of paths to modified/new/deleted note md files since last push.&#34;&#34;&#34;
    paths: Iterator[str]
    last_push_sha = get_last_push_sha(repo)

    # Treat case where there is no last push.
    if last_push_sha == &#34;&#34;:
        dir_entries: Iterator[os.DirEntry] = os.scandir(repo.working_dir)
        paths = map(lambda entry: entry.path, dir_entries)

    else:
        # Use a `DiffIndex` to get the changed files.
        files = []
        hcommit = repo.head.commit
        diff_index = hcommit.diff(last_push_sha)
        for change_type in CHANGE_TYPES:
            for diff in diff_index.iter_change_type(change_type):
                files.append(diff.a_path)
                files.append(diff.b_path)
        paths = [os.path.join(repo.working_dir, file) for file in files]
        paths = set(paths)

    changed = []
    for path in paths:
        if os.path.isfile(path) and not is_anki_note(path):
            continue
        changed.append(path)

    return changed


@beartype
def get_ephemeral_repo(suffix: str, repo: git.Repo, md5sum: str, sha: str) -&gt; git.Repo:
    &#34;&#34;&#34;
    Clone the git repo at `repo` into an ephemeral repo.

    Parameters
    ----------
    suffix : str
        /tmp/.../ path suffix, e.g. `ki/local/`.
    repo : git.Repo
        The git repository to clone.
    md5sum : str
        The md5sum of the associated anki collection.
    sha : str
        The commit SHA to reset --hard to.

    Returns
    -------
    git.Repo
        The cloned repository.
    &#34;&#34;&#34;
    # Git clone `repo` at latest commit in `/tmp/.../&lt;suffix&gt;/&lt;md5sum&gt;`.
    assert os.path.isdir(repo.working_dir)
    root = os.path.join(tempfile.mkdtemp(), suffix)
    os.makedirs(root)
    target = os.path.join(root, md5sum)
    git.Repo.clone_from(repo.working_dir, target, branch=repo.active_branch)

    # Do a reset --hard to the given SHA.
    ephem: git.Repo = git.Repo(target)
    ephem.git.reset(sha, hard=True)
    return ephem


@beartype
def update_last_push_commit_sha(repo: git.Repo) -&gt; None:
    &#34;&#34;&#34;Dump the SHA of current HEAD commit to ``last_push file``.&#34;&#34;&#34;
    last_push_path = os.path.join(repo.working_dir, &#34;.ki/&#34;, &#34;last_push&#34;)
    with open(last_push_path, &#34;w&#34;, encoding=&#34;UTF-8&#34;) as last_push_file:
        last_push_file.write(f&#34;{str(repo.head.commit)}&#34;)


@beartype
def echo(string: str, silent: bool = False) -&gt; None:
    &#34;&#34;&#34;Call `click.secho()` with formatting.&#34;&#34;&#34;
    if not silent:
        click.secho(string, bold=True)


@beartype
def append_md5sum(kidir: str, collection: str, md5sum: str, silent: bool = False) -&gt; None:
    &#34;&#34;&#34;Append an md5sum hash to the hashes file.&#34;&#34;&#34;
    basename = os.path.basename(collection)
    hashes_path = os.path.join(kidir, &#34;hashes&#34;)
    with open(hashes_path, &#34;a&#34;, encoding=&#34;UTF-8&#34;) as hashes_file:
        hashes_file.write(f&#34;{md5sum}  {basename}&#34;)
    echo(f&#34;Wrote md5sum to &#39;{hashes_path}&#39;&#34;, silent)


@beartype
def add_note_from_notemap(apyanki: Anki, notemap: Dict[str, Any]) -&gt; KiNote:
    &#34;&#34;&#34;Add a note given its `apy` parsed notemap.&#34;&#34;&#34;
    model_name = notemap[&#34;model&#34;]

    # Set current notetype for collection to `model_name`.
    model = apyanki.set_model(model_name)

    model_field_names = [field[&#34;name&#34;] for field in model[&#34;flds&#34;]]

    field_names = notemap[&#34;fields&#34;].keys()
    field_values = notemap[&#34;fields&#34;].values()

    if len(field_names) != len(model_field_names):
        click.echo(f&#34;Error: Not enough fields for model {model_name}!&#34;)
        apyanki.modified = False
        raise click.Abort()

    for x, y in zip(model_field_names, field_names):
        if x != y:
            click.echo(&#34;Warning: Inconsistent field names &#34; f&#34;({x} != {y})&#34;)

    # pylint: disable=protected-access
    note = _add_note(
        apyanki,
        field_values,
        f&#34;{notemap[&#39;tags&#39;]}&#34;,
        notemap[&#34;markdown&#34;],
        notemap.get(&#34;deck&#34;),
    )

    return note


@beartype
def _add_note(
    apyanki: Anki,
    fields: Iterable[str],
    tags: str,
    markdown: bool = True,
    deck: Optional[str] = None,
) -&gt; KiNote:
    &#34;&#34;&#34;Add new note to collection. Apy method.&#34;&#34;&#34;
    notetype = apyanki.col.models.current(for_deck=False)
    note = apyanki.col.new_note(notetype)

    if deck is not None:
        note.note_type()[&#34;did&#34;] = apyanki.deck_name_to_id[deck]

    if markdown:
        note.fields = [markdown_to_html(x) for x in fields]
    else:
        note.fields = [plain_to_html(x) for x in fields]

    for tag in tags.strip().split():
        note.add_tag(tag)

    fields_health_check: int = note.fields_check()
    if fields_health_check == 0:
        apyanki.col.addNote(note)
        apyanki.modified = True
    elif fields_health_check == 2:
        logger.warning(
            f&#34;\nDetected duplicate note while trying to add new note with nid {note.id}.&#34;
        )
        logger.warning(
            f&#34;Note type and field values of note {note.id} exactly match an existing note.&#34;
        )
        logger.warning(&#34;Note was not added to collection!&#34;)
        logger.warning(f&#34;First field: {list(fields)[0]}&#34;)
        logger.warning(f&#34;Fields health check: {fields_health_check}&#34;)
    else:
        logger.error(f&#34;Failed to add note &#39;{note.id}&#39;.&#34;)
        logger.error(
            f&#34;Note failed fields health check with error code: {fields_health_check}&#34;
        )

    return KiNote(apyanki, note)</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="ki.note" href="note.html">ki.note</a></code></dt>
<dd>
<div class="desc"><p>A module containing a class for Anki notes.</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ki.add_note_from_notemap"><code class="name flex">
<span>def <span class="ident">add_note_from_notemap</span></span>(<span>apyanki: apy.anki.Anki, notemap: dict) ‑> <a title="ki.note.KiNote" href="note.html#ki.note.KiNote">KiNote</a></span>
</code></dt>
<dd>
<div class="desc"><p>Add a note given its <code>apy</code> parsed notemap.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def add_note_from_notemap(apyanki: Anki, notemap: Dict[str, Any]) -&gt; KiNote:
    &#34;&#34;&#34;Add a note given its `apy` parsed notemap.&#34;&#34;&#34;
    model_name = notemap[&#34;model&#34;]

    # Set current notetype for collection to `model_name`.
    model = apyanki.set_model(model_name)

    model_field_names = [field[&#34;name&#34;] for field in model[&#34;flds&#34;]]

    field_names = notemap[&#34;fields&#34;].keys()
    field_values = notemap[&#34;fields&#34;].values()

    if len(field_names) != len(model_field_names):
        click.echo(f&#34;Error: Not enough fields for model {model_name}!&#34;)
        apyanki.modified = False
        raise click.Abort()

    for x, y in zip(model_field_names, field_names):
        if x != y:
            click.echo(&#34;Warning: Inconsistent field names &#34; f&#34;({x} != {y})&#34;)

    # pylint: disable=protected-access
    note = _add_note(
        apyanki,
        field_values,
        f&#34;{notemap[&#39;tags&#39;]}&#34;,
        notemap[&#34;markdown&#34;],
        notemap.get(&#34;deck&#34;),
    )

    return note</code></pre>
</details>
</dd>
<dt id="ki.append_md5sum"><code class="name flex">
<span>def <span class="ident">append_md5sum</span></span>(<span>kidir: str, collection: str, md5sum: str, silent: bool = False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Append an md5sum hash to the hashes file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def append_md5sum(kidir: str, collection: str, md5sum: str, silent: bool = False) -&gt; None:
    &#34;&#34;&#34;Append an md5sum hash to the hashes file.&#34;&#34;&#34;
    basename = os.path.basename(collection)
    hashes_path = os.path.join(kidir, &#34;hashes&#34;)
    with open(hashes_path, &#34;a&#34;, encoding=&#34;UTF-8&#34;) as hashes_file:
        hashes_file.write(f&#34;{md5sum}  {basename}&#34;)
    echo(f&#34;Wrote md5sum to &#39;{hashes_path}&#39;&#34;, silent)</code></pre>
</details>
</dd>
<dt id="ki.backup"><code class="name flex">
<span>def <span class="ident">backup</span></span>(<span>collection: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Backup collection to <code>.ki/backups</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def backup(collection: str) -&gt; None:
    &#34;&#34;&#34;Backup collection to `.ki/backups`.&#34;&#34;&#34;
    md5sum = md5(collection)
    backupsdir = os.path.join(os.getcwd(), &#34;.ki/&#34;, &#34;backups&#34;)
    assert not os.path.isfile(backupsdir)
    if not os.path.isdir(backupsdir):
        os.mkdir(backupsdir)
    backup_path = os.path.join(backupsdir, f&#34;{md5sum}.anki2&#34;)
    if os.path.isfile(backup_path):
        click.secho(&#34;Backup already exists.&#34;, bold=True)
        return
    assert not os.path.isfile(backup_path)
    echo(f&#34;Writing backup of .anki2 file to &#39;{backupsdir}&#39;&#34;)
    shutil.copyfile(collection, backup_path)
    assert os.path.isfile(backup_path)</code></pre>
</details>
</dd>
<dt id="ki.delete_notes"><code class="name flex">
<span>def <span class="ident">delete_notes</span></span>(<span>apyanki: apy.anki.Anki, ids: collections.abc.Sequence) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Delete notes by note ids</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def delete_notes(apyanki: Anki, ids: Sequence[int]) -&gt; None:
    &#34;&#34;&#34;Delete notes by note ids&#34;&#34;&#34;
    if not isinstance(ids, list):
        ids = [ids]

    op_changes = apyanki.col.remove_notes(ids)
    apyanki.modified = True</code></pre>
</details>
</dd>
<dt id="ki.echo"><code class="name flex">
<span>def <span class="ident">echo</span></span>(<span>string: str, silent: bool = False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Call <code>click.secho()</code> with formatting.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def echo(string: str, silent: bool = False) -&gt; None:
    &#34;&#34;&#34;Call `click.secho()` with formatting.&#34;&#34;&#34;
    if not silent:
        click.secho(string, bold=True)</code></pre>
</details>
</dd>
<dt id="ki.get_default_clone_directory"><code class="name flex">
<span>def <span class="ident">get_default_clone_directory</span></span>(<span>collection_path: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>"
Get the default clone directory path.</p>
<p>This should just be the name of the collection (which is usually a file
called <code>collection.anki2</code>) so this will usually be <code>./collection/</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>collection_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to a <code>.anki2</code> collection file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The path to clone into.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def get_default_clone_directory(collection_path: str) -&gt; str:
    &#34;&#34;&#34; &#34;
    Get the default clone directory path.

    This should just be the name of the collection (which is usually a file
    called `collection.anki2`) so this will usually be `./collection/`.

    Parameters
    ----------
    collection_path : str
        The path to a `.anki2` collection file.

    Returns
    -------
    str
        The path to clone into.
    &#34;&#34;&#34;
    basename = os.path.basename(collection_path)
    sections = os.path.splitext(basename)
    assert len(sections) == 2
    return os.path.abspath(sections[0])</code></pre>
</details>
</dd>
<dt id="ki.get_ephemeral_repo"><code class="name flex">
<span>def <span class="ident">get_ephemeral_repo</span></span>(<span>suffix: str, repo: git.repo.base.Repo, md5sum: str, sha: str) ‑> git.repo.base.Repo</span>
</code></dt>
<dd>
<div class="desc"><p>Clone the git repo at <code>repo</code> into an ephemeral repo.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>suffix</code></strong> :&ensp;<code>str</code></dt>
<dd>/tmp/&hellip;/ path suffix, e.g. <code>ki/local/</code>.</dd>
<dt><strong><code>repo</code></strong> :&ensp;<code>git.Repo</code></dt>
<dd>The git repository to clone.</dd>
<dt><strong><code>md5sum</code></strong> :&ensp;<code>str</code></dt>
<dd>The md5sum of the associated anki collection.</dd>
<dt><strong><code>sha</code></strong> :&ensp;<code>str</code></dt>
<dd>The commit SHA to reset &ndash;hard to.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>git.Repo</code></dt>
<dd>The cloned repository.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def get_ephemeral_repo(suffix: str, repo: git.Repo, md5sum: str, sha: str) -&gt; git.Repo:
    &#34;&#34;&#34;
    Clone the git repo at `repo` into an ephemeral repo.

    Parameters
    ----------
    suffix : str
        /tmp/.../ path suffix, e.g. `ki/local/`.
    repo : git.Repo
        The git repository to clone.
    md5sum : str
        The md5sum of the associated anki collection.
    sha : str
        The commit SHA to reset --hard to.

    Returns
    -------
    git.Repo
        The cloned repository.
    &#34;&#34;&#34;
    # Git clone `repo` at latest commit in `/tmp/.../&lt;suffix&gt;/&lt;md5sum&gt;`.
    assert os.path.isdir(repo.working_dir)
    root = os.path.join(tempfile.mkdtemp(), suffix)
    os.makedirs(root)
    target = os.path.join(root, md5sum)
    git.Repo.clone_from(repo.working_dir, target, branch=repo.active_branch)

    # Do a reset --hard to the given SHA.
    ephem: git.Repo = git.Repo(target)
    ephem.git.reset(sha, hard=True)
    return ephem</code></pre>
</details>
</dd>
<dt id="ki.get_last_push_sha"><code class="name flex">
<span>def <span class="ident">get_last_push_sha</span></span>(<span>repo: git.repo.base.Repo) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Get LAST_PUSH SHA.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def get_last_push_sha(repo: git.Repo) -&gt; str:
    &#34;&#34;&#34;Get LAST_PUSH SHA.&#34;&#34;&#34;
    last_push_path = os.path.join(repo.working_dir, &#34;.ki/&#34;, &#34;last_push&#34;)
    with open(last_push_path, &#34;r&#34;, encoding=&#34;UTF-8&#34;) as last_push_file:
        sha = last_push_file.read()
    return sha</code></pre>
</details>
</dd>
<dt id="ki.get_latest_collection_hash"><code class="name flex">
<span>def <span class="ident">get_latest_collection_hash</span></span>(<span>) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Get the last collection hash stored in <code>.ki/hashes</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def get_latest_collection_hash() -&gt; str:
    &#34;&#34;&#34;Get the last collection hash stored in `.ki/hashes`.&#34;&#34;&#34;
    kidir = os.path.join(os.getcwd(), &#34;.ki/&#34;)
    hashes_path = os.path.join(kidir, &#34;hashes&#34;)
    with open(hashes_path, &#34;r&#34;, encoding=&#34;UTF-8&#34;) as hashes_file:
        return hashes_file.readlines()[-1]</code></pre>
</details>
</dd>
<dt id="ki.get_nids"><code class="name flex">
<span>def <span class="ident">get_nids</span></span>(<span>path: str) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Get just nids from a markdown note.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def get_nids(path: str) -&gt; List[int]:
    &#34;&#34;&#34;Get just nids from a markdown note.&#34;&#34;&#34;
    notemaps = parse_markdown_notes(path)
    return [notemap[&#34;nid&#34;] for notemap in notemaps]</code></pre>
</details>
</dd>
<dt id="ki.get_note_files_changed_since_last_push"><code class="name flex">
<span>def <span class="ident">get_note_files_changed_since_last_push</span></span>(<span>repo: git.repo.base.Repo) ‑> collections.abc.Sequence</span>
</code></dt>
<dd>
<div class="desc"><p>Gets a list of paths to modified/new/deleted note md files since last push.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def get_note_files_changed_since_last_push(repo: git.Repo) -&gt; Sequence[str]:
    &#34;&#34;&#34;Gets a list of paths to modified/new/deleted note md files since last push.&#34;&#34;&#34;
    paths: Iterator[str]
    last_push_sha = get_last_push_sha(repo)

    # Treat case where there is no last push.
    if last_push_sha == &#34;&#34;:
        dir_entries: Iterator[os.DirEntry] = os.scandir(repo.working_dir)
        paths = map(lambda entry: entry.path, dir_entries)

    else:
        # Use a `DiffIndex` to get the changed files.
        files = []
        hcommit = repo.head.commit
        diff_index = hcommit.diff(last_push_sha)
        for change_type in CHANGE_TYPES:
            for diff in diff_index.iter_change_type(change_type):
                files.append(diff.a_path)
                files.append(diff.b_path)
        paths = [os.path.join(repo.working_dir, file) for file in files]
        paths = set(paths)

    changed = []
    for path in paths:
        if os.path.isfile(path) and not is_anki_note(path):
            continue
        changed.append(path)

    return changed</code></pre>
</details>
</dd>
<dt id="ki.is_anki_note"><code class="name flex">
<span>def <span class="ident">is_anki_note</span></span>(<span>path: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if file is an <code>apy</code>-style markdown anki note.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def is_anki_note(path: str) -&gt; bool:
    &#34;&#34;&#34;Check if file is an `apy`-style markdown anki note.&#34;&#34;&#34;
    # Ought to have markdown file extension.
    if path[-3:] != &#34;.md&#34;:
        return False
    with open(path, &#34;r&#34;, encoding=&#34;UTF-8&#34;) as md_file:
        lines = md_file.readlines()
    if len(lines) &lt; 2:
        return False
    if lines[0] != &#34;# Note\n&#34;:
        return False
    if not re.match(r&#34;^nid: [0-9]+$&#34;, lines[1]):
        return False
    return True</code></pre>
</details>
</dd>
<dt id="ki.lock"><code class="name flex">
<span>def <span class="ident">lock</span></span>(<span>collection: str) ‑> sqlite3.Connection</span>
</code></dt>
<dd>
<div class="desc"><p>Acquire a lock on a SQLite3 database given a path.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def lock(collection: str) -&gt; sqlite3.Connection:
    &#34;&#34;&#34;Acquire a lock on a SQLite3 database given a path.&#34;&#34;&#34;
    con = sqlite3.connect(collection)
    con.isolation_level = &#34;EXCLUSIVE&#34;
    con.execute(&#34;BEGIN EXCLUSIVE&#34;)
    return con</code></pre>
</details>
</dd>
<dt id="ki.md5"><code class="name flex">
<span>def <span class="ident">md5</span></span>(<span>path: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Compute md5sum of file at <code>path</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def md5(path: str) -&gt; str:
    &#34;&#34;&#34;Compute md5sum of file at `path`.&#34;&#34;&#34;
    hash_md5 = hashlib.md5()
    with open(path, &#34;rb&#34;) as f:
        for chunk in iter(lambda: f.read(4096), b&#34;&#34;):
            hash_md5.update(chunk)
    return hash_md5.hexdigest()</code></pre>
</details>
</dd>
<dt id="ki.open_repo"><code class="name flex">
<span>def <span class="ident">open_repo</span></span>(<span>) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Get collection path from <code>.ki/</code> directory.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def open_repo() -&gt; str:
    &#34;&#34;&#34;Get collection path from `.ki/` directory.&#34;&#34;&#34;
    # Check that config file exists.
    config_path = os.path.join(os.getcwd(), &#34;.ki/&#34;, &#34;config&#34;)
    if not os.path.isfile(config_path):
        raise FileNotFoundError

    # Parse config file.
    config = configparser.ConfigParser()
    config.read(config_path)
    collection = config[&#34;remote&#34;][&#34;path&#34;]

    if not os.path.isfile(collection):
        raise FileNotFoundError

    return collection</code></pre>
</details>
</dd>
<dt id="ki.parse_markdown_notes"><code class="name flex">
<span>def <span class="ident">parse_markdown_notes</span></span>(<span>path: str) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Parse nids from markdown file of notes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def parse_markdown_notes(path: str) -&gt; List[Dict[str, Any]]:
    &#34;&#34;&#34;Parse nids from markdown file of notes.&#34;&#34;&#34;
    # Support multiple notes-per-file.
    notemaps: List[Dict[str, Any]] = markdown_file_to_notes(path)
    casted_notemaps = []
    for notemap in notemaps:
        try:
            nid = int(notemap[&#34;nid&#34;])
            notemap[&#34;nid&#34;] = nid
            casted_notemaps.append(notemap)
        except KeyError as err:
            logger.error(&#34;Failed to parse nid.&#34;)
            logger.error(f&#34;notemap: {notemap}&#34;)
            logger.error(f&#34;path: {path}&#34;)
            raise err
    return casted_notemaps</code></pre>
</details>
</dd>
<dt id="ki.unlock"><code class="name flex">
<span>def <span class="ident">unlock</span></span>(<span>con: sqlite3.Connection) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Unlock a SQLite3 database.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def unlock(con: sqlite3.Connection) -&gt; None:
    &#34;&#34;&#34;Unlock a SQLite3 database.&#34;&#34;&#34;
    con.commit()
    con.close()</code></pre>
</details>
</dd>
<dt id="ki.update_apy_note"><code class="name flex">
<span>def <span class="ident">update_apy_note</span></span>(<span>note: <a title="ki.note.KiNote" href="note.html#ki.note.KiNote">KiNote</a>, notemap: dict) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Update an <code>apy</code> Note in a collection.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def update_apy_note(note: KiNote, notemap: Dict[str, Any]) -&gt; None:
    &#34;&#34;&#34;Update an `apy` Note in a collection.&#34;&#34;&#34;
    new_tags = notemap[&#34;tags&#34;].split()
    if new_tags != note.n.tags:
        note.n.tags = new_tags

    new_deck = notemap.get(&#34;deck&#34;, None)
    if new_deck is not None and new_deck != note.get_deck():
        note.set_deck(new_deck)

    for i, value in enumerate(notemap[&#34;fields&#34;].values()):
        if notemap[&#34;markdown&#34;]:
            note.n.fields[i] = markdown_to_html(value)
        else:
            note.n.fields[i] = plain_to_html(value)

    note.n.flush()
    note.a.modified = True
    fields_health_check = note.n.fields_check()

    if fields_health_check == 1:
        logger.warning(f&#34;Found empty note:\n {note}&#34;)
        return
    if fields_health_check == 2:
        logger.warning(f&#34;Found duplicate note:\n {note}&#34;)
        return

    if fields_health_check:
        logger.warning(f&#34;Found duplicate or empty note:\n {note}&#34;)
        logger.warning(f&#34;Fields health check: {fields_health_check}&#34;)
        logger.warning(f&#34;Fields health check (type): {type(fields_health_check)}&#34;)</code></pre>
</details>
</dd>
<dt id="ki.update_last_push_commit_sha"><code class="name flex">
<span>def <span class="ident">update_last_push_commit_sha</span></span>(<span>repo: git.repo.base.Repo) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Dump the SHA of current HEAD commit to <code>last_push file</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def update_last_push_commit_sha(repo: git.Repo) -&gt; None:
    &#34;&#34;&#34;Dump the SHA of current HEAD commit to ``last_push file``.&#34;&#34;&#34;
    last_push_path = os.path.join(repo.working_dir, &#34;.ki/&#34;, &#34;last_push&#34;)
    with open(last_push_path, &#34;w&#34;, encoding=&#34;UTF-8&#34;) as last_push_file:
        last_push_file.write(f&#34;{str(repo.head.commit)}&#34;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="ki Home" href="index.html">
<img src="u1F367-shavedice.svg" alt=""> ki
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#installation">Installation</a></li>
<li><a href="#usage">Usage</a><ul>
<li><a href="#cloning-an-anki-collection-into-a-new-ki-repository">Cloning an Anki collection into a new ki repository</a></li>
<li><a href="#pulling-changes-from-an-anki-collection-into-an-existing-ki-repository">Pulling changes from an Anki collection into an existing ki repository</a></li>
<li><a href="#pushing-changes-in-a-ki-repository-to-an-anki-collection">Pushing changes in a ki repository to an Anki collection</a></li>
</ul>
</li>
<li><a href="#editing-notes">Editing notes</a></li>
<li><a href="#how-it-works">How it works</a></li>
<li><a href="#model">Model</a></li>
<li><a href="#generating-html">Generating html</a><ul>
<li><a href="#example-generating-syntax-highlighted-code-blocks">Example: generating syntax-highlighted code blocks</a><ul>
<li><a href="#adding-ki-html-attributes">Adding ki HTML attributes</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="ki.note" href="note.html">ki.note</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="ki.add_note_from_notemap" href="#ki.add_note_from_notemap">add_note_from_notemap</a></code></li>
<li><code><a title="ki.append_md5sum" href="#ki.append_md5sum">append_md5sum</a></code></li>
<li><code><a title="ki.backup" href="#ki.backup">backup</a></code></li>
<li><code><a title="ki.delete_notes" href="#ki.delete_notes">delete_notes</a></code></li>
<li><code><a title="ki.echo" href="#ki.echo">echo</a></code></li>
<li><code><a title="ki.get_default_clone_directory" href="#ki.get_default_clone_directory">get_default_clone_directory</a></code></li>
<li><code><a title="ki.get_ephemeral_repo" href="#ki.get_ephemeral_repo">get_ephemeral_repo</a></code></li>
<li><code><a title="ki.get_last_push_sha" href="#ki.get_last_push_sha">get_last_push_sha</a></code></li>
<li><code><a title="ki.get_latest_collection_hash" href="#ki.get_latest_collection_hash">get_latest_collection_hash</a></code></li>
<li><code><a title="ki.get_nids" href="#ki.get_nids">get_nids</a></code></li>
<li><code><a title="ki.get_note_files_changed_since_last_push" href="#ki.get_note_files_changed_since_last_push">get_note_files_changed_since_last_push</a></code></li>
<li><code><a title="ki.is_anki_note" href="#ki.is_anki_note">is_anki_note</a></code></li>
<li><code><a title="ki.lock" href="#ki.lock">lock</a></code></li>
<li><code><a title="ki.md5" href="#ki.md5">md5</a></code></li>
<li><code><a title="ki.open_repo" href="#ki.open_repo">open_repo</a></code></li>
<li><code><a title="ki.parse_markdown_notes" href="#ki.parse_markdown_notes">parse_markdown_notes</a></code></li>
<li><code><a title="ki.unlock" href="#ki.unlock">unlock</a></code></li>
<li><code><a title="ki.update_apy_note" href="#ki.update_apy_note">update_apy_note</a></code></li>
<li><code><a title="ki.update_last_push_commit_sha" href="#ki.update_last_push_commit_sha">update_last_push_commit_sha</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>